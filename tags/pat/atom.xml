<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: PAT | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.io/tags/pat/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.io/"/>
  <updated>2016-04-19T00:27:46+08:00</updated>
  <id>http://biaobiaoqi.github.io/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PAT 1069 - 1072 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072/"/>
    <updated>2013-11-07T00:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072</id>
    <content type="html"><![CDATA[<p>来源是 2013 年 11 月 2 日的PAT测试。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1069">1069. The Black Hole of Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个四位数比如6767，将它按照每位从小到大(6677)和从大到小(7766)充足，得到两个新四位数，这两者相减将得到一个新的四位数。再按照一样的处理方式处理得出的四位数</p>

<p>```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174</p>

<p>```</p>

<p>最终将得到一个『黑洞数』：6174。</p>

<p>题目给出一个四位数，要求输出它演变出『黑洞数』的过程。</p>

<!--more-->


<h5>分析</h5>

<p>简单模拟题，需要留心两个特殊情况的处理：<code>6174</code>，<code>xxxx</code>。</p>

<p>熟练掌握 C 的基本函数也能缩短代码编写，比如<code>atoi()</code> 和 <code>sprintf()</code>， 由于<code>itoa()</code>是依赖于Windows的，这里不推荐使用。</p>

<p>pat1069源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1069.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1070">1070. Mooncake (25)</a></h2>

<h5>题意</h5>

<p>给出月饼市场的需求 D&lt;= 500 （按重量计算），给出现有 N &lt;= 1000 种月饼，每种月饼有一定数量的储备（按重量计算）以及这些储备所对应的价格，求一个出售月饼的方式，在容量D的市场里，获得最多的销售额。</p>

<h5>分析</h5>

<p>简单的贪心问题。贪心的规则是月饼的单价。注意有一个坑：每种月饼的存货量也需要用<code>double</code>来做存储。</p>

<p>pat1070源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1070.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1071">1071. Speech Patterns (25)</a></h2>

<h5>题意</h5>

<p>给出一个长度不超过 1048576 的字符串。把所有连续的字母或者数字（[0-9 A-Z a-z]）试做单词，且忽略大小写，求其中最高频的单词。</p>

<h5>分析</h5>

<p>使用map&lt;string, int>做存储，统计出现次数即可。</p>

<p>有些细节需要注意：</p>

<ul>
<li>使用<code>getline(cin, str)</code>获取正行数据</li>
<li>使用<code>transform(str.begin(), str.end(), str.begin(), ::tolower);</code>将字符串转换成小写</li>
<li>遍历字符串获取单词时，注意特殊条件。比如以非字符数字开头的字符串，以字符数字结尾的字符串等。</li>
</ul>


<p>pat1071源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1071.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1072">1072. Gas Station (30)</a></h2>

<h5>题意</h5>

<p>给出一个图，其中有 N &lt;= 10<sup>3</sup> 个节点是居民房，M &lt;= 10 个节点是计划建造加油站的候选点。给出加油站所能服务的最远距离 D。要求计算出合适的位置建造加油站，满足如下优先级条件：</p>

<ol>
<li>所有居民房必须在加油站的服务距离内。</li>
<li>所有居民房中距离加油站的最近的居民房与加油站之间的距离是最远的。（大概是安全方面的考虑，加油站要离居民区远一点）</li>
<li>所有房间距离加油站的最小距离的总和最小。（节约居民加油的总体成本）</li>
<li>同等条件下，序号越小的加油站优先。</li>
</ol>


<h5>分析</h5>

<p>实际上是求加油站到所有点的最短路径的问题，使用Dijsktra可以满足。</p>

<p>另外，需要考虑求最短路径的过程中是否要将其他加油站所构建的路径算入在内。从背景上看，加油站应该在公路边修建，故加油站之间以及居民房和加油站之间都是存在路径的，从给出的数据来看，存在两个加油站之间的路径。所以，计算最短路径时，是需要将所有加油站的节点也计算在内的。</p>

<p>pat1072源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1072.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1069 - 1072 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072/"/>
    <updated>2013-11-07T00:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072</id>
    <content type="html"><![CDATA[<p>来源是 2013 年 11 月 2 日的PAT测试。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1069">1069. The Black Hole of Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个四位数比如6767，将它按照每位从小到大(6677)和从大到小(7766)充足，得到两个新四位数，这两者相减将得到一个新的四位数。再按照一样的处理方式处理得出的四位数</p>

<p>```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174</p>

<p>```</p>

<p>最终将得到一个『黑洞数』：6174。</p>

<p>题目给出一个四位数，要求输出它演变出『黑洞数』的过程。</p>

<!--more-->


<h5>分析</h5>

<p>简单模拟题，需要留心两个特殊情况的处理：<code>6174</code>，<code>xxxx</code>。</p>

<p>熟练掌握 C 的基本函数也能缩短代码编写，比如<code>atoi()</code> 和 <code>sprintf()</code>， 由于<code>itoa()</code>是依赖于Windows的，这里不推荐使用。</p>

<p>pat1069源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1069.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1070">1070. Mooncake (25)</a></h2>

<h5>题意</h5>

<p>给出月饼市场的需求 D&lt;= 500 （按重量计算），给出现有 N &lt;= 1000 种月饼，每种月饼有一定数量的储备（按重量计算）以及这些储备所对应的价格，求一个出售月饼的方式，在容量D的市场里，获得最多的销售额。</p>

<h5>分析</h5>

<p>简单的贪心问题。贪心的规则是月饼的单价。注意有一个坑：每种月饼的存货量也需要用<code>double</code>来做存储。</p>

<p>pat1070源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1070.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1071">1071. Speech Patterns (25)</a></h2>

<h5>题意</h5>

<p>给出一个长度不超过 1048576 的字符串。把所有连续的字母或者数字（[0-9 A-Z a-z]）试做单词，且忽略大小写，求其中最高频的单词。</p>

<h5>分析</h5>

<p>使用map&lt;string, int>做存储，统计出现次数即可。</p>

<p>有些细节需要注意：</p>

<ul>
<li>使用<code>getline(cin, str)</code>获取正行数据</li>
<li>使用<code>transform(str.begin(), str.end(), str.begin(), ::tolower);</code>将字符串转换成小写</li>
<li>遍历字符串获取单词时，注意特殊条件。比如以非字符数字开头的字符串，以字符数字结尾的字符串等。</li>
</ul>


<p>pat1071源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1071.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1072">1072. Gas Station (30)</a></h2>

<h5>题意</h5>

<p>给出一个图，其中有 N &lt;= 10<sup>3</sup> 个节点是居民房，M &lt;= 10 个节点是计划建造加油站的候选点。给出加油站所能服务的最远距离 D。要求计算出合适的位置建造加油站，满足如下优先级条件：</p>

<ol>
<li>所有居民房必须在加油站的服务距离内。</li>
<li>所有居民房中距离加油站的最近的居民房与加油站之间的距离是最远的。（大概是安全方面的考虑，加油站要离居民区远一点）</li>
<li>所有房间距离加油站的最小距离的总和最小。（节约居民加油的总体成本）</li>
<li>同等条件下，序号越小的加油站优先。</li>
</ol>


<h5>分析</h5>

<p>实际上是求加油站到所有点的最短路径的问题，使用Dijsktra可以满足。</p>

<p>另外，需要考虑求最短路径的过程中是否要将其他加油站所构建的路径算入在内。从背景上看，加油站应该在公路边修建，故加油站之间以及居民房和加油站之间都是存在路径的，从给出的数据来看，存在两个加油站之间的路径。所以，计算最短路径时，是需要将所有加油站的节点也计算在内的。</p>

<p>pat1072源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1072.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1069 - 1072 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072/"/>
    <updated>2013-11-07T00:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072</id>
    <content type="html"><![CDATA[<p>来源是 2013 年 11 月 2 日的PAT测试。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1069">1069. The Black Hole of Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个四位数比如6767，将它按照每位从小到大(6677)和从大到小(7766)充足，得到两个新四位数，这两者相减将得到一个新的四位数。再按照一样的处理方式处理得出的四位数</p>

<p>```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174</p>

<p>```</p>

<p>最终将得到一个『黑洞数』：6174。</p>

<p>题目给出一个四位数，要求输出它演变出『黑洞数』的过程。</p>

<!--more-->


<h5>分析</h5>

<p>简单模拟题，需要留心两个特殊情况的处理：<code>6174</code>，<code>xxxx</code>。</p>

<p>熟练掌握 C 的基本函数也能缩短代码编写，比如<code>atoi()</code> 和 <code>sprintf()</code>， 由于<code>itoa()</code>是依赖于Windows的，这里不推荐使用。</p>

<p>pat1069源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1069.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1070">1070. Mooncake (25)</a></h2>

<h5>题意</h5>

<p>给出月饼市场的需求 D&lt;= 500 （按重量计算），给出现有 N &lt;= 1000 种月饼，每种月饼有一定数量的储备（按重量计算）以及这些储备所对应的价格，求一个出售月饼的方式，在容量D的市场里，获得最多的销售额。</p>

<h5>分析</h5>

<p>简单的贪心问题。贪心的规则是月饼的单价。注意有一个坑：每种月饼的存货量也需要用<code>double</code>来做存储。</p>

<p>pat1070源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1070.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1071">1071. Speech Patterns (25)</a></h2>

<h5>题意</h5>

<p>给出一个长度不超过 1048576 的字符串。把所有连续的字母或者数字（[0-9 A-Z a-z]）试做单词，且忽略大小写，求其中最高频的单词。</p>

<h5>分析</h5>

<p>使用map&lt;string, int>做存储，统计出现次数即可。</p>

<p>有些细节需要注意：</p>

<ul>
<li>使用<code>getline(cin, str)</code>获取正行数据</li>
<li>使用<code>transform(str.begin(), str.end(), str.begin(), ::tolower);</code>将字符串转换成小写</li>
<li>遍历字符串获取单词时，注意特殊条件。比如以非字符数字开头的字符串，以字符数字结尾的字符串等。</li>
</ul>


<p>pat1071源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1071.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1072">1072. Gas Station (30)</a></h2>

<h5>题意</h5>

<p>给出一个图，其中有 N &lt;= 10<sup>3</sup> 个节点是居民房，M &lt;= 10 个节点是计划建造加油站的候选点。给出加油站所能服务的最远距离 D。要求计算出合适的位置建造加油站，满足如下优先级条件：</p>

<ol>
<li>所有居民房必须在加油站的服务距离内。</li>
<li>所有居民房中距离加油站的最近的居民房与加油站之间的距离是最远的。（大概是安全方面的考虑，加油站要离居民区远一点）</li>
<li>所有房间距离加油站的最小距离的总和最小。（节约居民加油的总体成本）</li>
<li>同等条件下，序号越小的加油站优先。</li>
</ol>


<h5>分析</h5>

<p>实际上是求加油站到所有点的最短路径的问题，使用Dijsktra可以满足。</p>

<p>另外，需要考虑求最短路径的过程中是否要将其他加油站所构建的路径算入在内。从背景上看，加油站应该在公路边修建，故加油站之间以及居民房和加油站之间都是存在路径的，从给出的数据来看，存在两个加油站之间的路径。所以，计算最短路径时，是需要将所有加油站的节点也计算在内的。</p>

<p>pat1072源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1072.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1065 - 1068 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/10/08/pat-1065-pat-1068/"/>
    <updated>2013-10-08T13:46:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/10/08/pat-1065-pat-1068</id>
    <content type="html"><![CDATA[<p>这次的题目来源是2013年10月7日下午的浙大计算机研究生招生机试题。</p>

<p>这次题目的难度，按姥姥的说法是：『比普通的PAT要难了0.5个点。我是把自己的题目从1.0到5.0以0.5的间距分难度级别的，PAT(A)难度一般在1.5-4.5之间，保研考试一般在2.0-5.0之间。PAT(B)大概是1.0-2.5的难度。』。</p>

<p>个人认为，其中1066模拟AVL插入的实现有些细节容易弄错，而1068只要会简单的DP，也就没有问题了，1065和1066都还是很简单的实现。</p>

<p>下面是各个题的分析（PAT advanced level本人实现的全部源码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a>）。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1065">1065. A+B and C (64bit) (20)</a></h2>

<h5>题意</h5>

<p>输入三个数a，b，c，取值范围是 [<code>-2^63</code>, <code>2^63</code>]，要求判断<code>a + b &lt; c</code> 是否为真。</p>

<h5>分析</h5>

<p>很简单的签到题，想到两种方法：一是用Java的Big Decimal实现（应该不会超时吧-,-），二是对a+b造成的long long溢出的情况做特殊处理。</p>

<p>对于分情况的实现方式，实际上也就两种特殊情况，即a，b同号且两者之和溢出了（绝对值超过了2<sup>63）。此时两者之和与c的值的相对关系也是确定的。</sup></p>

<ul>
<li><code>a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; a + b &gt;= 0</code>: a + b 必小于c</li>
<li><code>a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a + b &lt;= 0</code>: a + b 必大于c</li>
</ul>


<p>另在98看见有大神说可以用long double水过去-,-.</p>

<p>pat1065源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1065.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1066">1066. Root of AVL Tree (25)</a></h2>

<h5>题意</h5>

<p>实现<a href="http://en.wikipedia.org/wiki/AVL_tree">AVL树</a>的插入方法，给定N(&lt;=20)个数，要求输出依次插入后的AVL树的根。</p>

<h5>分析</h5>

<p>由于节点少，可以使用相对简单的递归实现方法：</p>

<ul>
<li>每个节点维护一个高度值，用在递归插入后检测子树是否平衡</li>
<li>完成4个旋转方法（参见<a href="http://en.wikipedia.org/wiki/AVL_tree">AVL Tree wikipedia</a>中的示意图）</li>
<li>在递归插入方法中，完成对子树的插入后，检测子树高度差，根据子树的结构特点，做出相应的旋转</li>
<li>旋转后记得更新节点的高度值</li>
</ul>


<p>机试时似乎没有人完全AC这道题，看来代码实现和Debug能力缺乏还是比较普遍的问题。</p>

<p>pat1066源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1066.cpp">请戳</a></p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1067">1067. Sort with Swap(0,*) (25)</a></h2>

<h5>题意</h5>

<p>给定N(&lt;=<code>10^5</code>)以及一个{0,1,…,N-1}的打乱的数列。</p>

<p>定义了一种交换方式：<code>Swap(0,*)</code>，表示将0和任意数进行位置交换。</p>

<p>限定只能使用<code>Swap(0,*)</code>，要求输出最少需要多少次交换操作，来完成整体的排序。</p>

<h5>分析</h5>

<p>很好玩的模拟题，从题目的两个测试数据入手，找到所需要的交换次数的特点：</p>

<p>假设用数组a存储输入的数组，数组的坐标为[0, N - 1]，而元素的所有值也是[0, N - 1]。</p>

<ol>
<li><p>输入的序列中本就在自己位置上的数字，是不用被交换的（比如序列<code>{4, 0, 2, 1, 3}</code>中2就是不用被交换），0除外</p></li>
<li><p>0最终肯定会被放回到0的位置上，但交换过程中，0也可能被提前交换到了0的位置上，此时还有其他数没有处于正确的位置上（参见Sample Input<code>{10 3 5 7 2 6 4 9 0 8 1}</code>的情况）。此时需要多费一步将0和某一个处于不正确位置的数交换位置，来继续排序。</p></li>
<li><p>每次的交换，0其实只是一个过渡作用。实际的交换过程遵循的链式关系如下所述：设定a[x] == b， 而 b != x，则需要将a[x]的值移动到a[b]上，此时a[b] == c, 那么接着又需要将 a[b]的值移动到a[c]上，以此类推，肯定能获得一个循环，且节点数 M 小于等于 N。如果循环中包含了0，那么这个循环中的数排序所需要的交换次数为 M - 1, 如果循环中不包含0，那么首先需要一次交换将0移动到循环链中，此时整个循环链节点数增加了1，于是共需要开销 M + 1 次交换。</p></li>
<li><p>根据3的分析，在2的情况下，0与不同的不在正确位置的数的交换，是不会影响最终的结果的。</p></li>
</ol>


<p>综上所述，用类似dfs或者并查集的思路找到集合中的所有循环链路，记录下他们的大小，即可计算出所需要的交换次数。</p>

<p>pat1067源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1067.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1068">1068. Find More Coins (30)</a></h2>

<h5>题意</h5>

<p>给定 N(&lt;=<code>10^4</code>) 枚硬币和一个价格 M(&lt;=100)。</p>

<p>要求用这 N 枚硬币组合出价格 M，如果有多种组合，输出排序后硬币面值字典序最小的组合，如果没有组合，则输出 No Solution.</p>

<h5>分析</h5>

<p>裸背包问题，相关资料参见dd大神的总结：<a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">《背包问题九讲》</a></p>

<p>按照常规的背包思路，构建10001 * 101 的二维数组f[i][j]，状态f[i][j]表示前i枚硬币能拼凑出的小于等于j的最大值（j这里代表一个价格）。</p>

<p>状态转移方程为：<code>f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + c[i])</code>， 其中c[i]为第i枚硬币的面值，c[i]为排序过的硬币面值数组。</p>

<p>由于最终的输出要求是排序的币值的字典序最小的组合，可以对c[i]做从大到小的排序，并另开一个数组has[i][j]来记录当前状态下，是否有包含c[i]。同时注意，当<code>f[i - 1][j] == f[i - 1][j - c[i]] + c[i]</code>时，采纳当前的c[i]，以满足字典序。</p>

<p>pat1068源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1068.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1065 - 1068 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/10/08/pat-1065-pat-1068/"/>
    <updated>2013-10-08T13:46:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/10/08/pat-1065-pat-1068</id>
    <content type="html"><![CDATA[<p>这次的题目来源是2013年10月7日下午的浙大计算机研究生招生机试题。</p>

<p>这次题目的难度，按姥姥的说法是：『比普通的PAT要难了0.5个点。我是把自己的题目从1.0到5.0以0.5的间距分难度级别的，PAT(A)难度一般在1.5-4.5之间，保研考试一般在2.0-5.0之间。PAT(B)大概是1.0-2.5的难度。』。</p>

<p>个人认为，其中1066模拟AVL插入的实现有些细节容易弄错，而1068只要会简单的DP，也就没有问题了，1065和1066都还是很简单的实现。</p>

<p>下面是各个题的分析（PAT advanced level本人实现的全部源码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a>）。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1065">1065. A+B and C (64bit) (20)</a></h2>

<h5>题意</h5>

<p>输入三个数a，b，c，取值范围是 [<code>-2^63</code>, <code>2^63</code>]，要求判断<code>a + b &lt; c</code> 是否为真。</p>

<h5>分析</h5>

<p>很简单的签到题，想到两种方法：一是用Java的Big Decimal实现（应该不会超时吧-,-），二是对a+b造成的long long溢出的情况做特殊处理。</p>

<p>对于分情况的实现方式，实际上也就两种特殊情况，即a，b同号且两者之和溢出了（绝对值超过了2<sup>63）。此时两者之和与c的值的相对关系也是确定的。</sup></p>

<ul>
<li><code>a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; a + b &gt;= 0</code>: a + b 必小于c</li>
<li><code>a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a + b &lt;= 0</code>: a + b 必大于c</li>
</ul>


<p>另在98看见有大神说可以用long double水过去-,-.</p>

<p>pat1065源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1065.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1066">1066. Root of AVL Tree (25)</a></h2>

<h5>题意</h5>

<p>实现<a href="http://en.wikipedia.org/wiki/AVL_tree">AVL树</a>的插入方法，给定N(&lt;=20)个数，要求输出依次插入后的AVL树的根。</p>

<h5>分析</h5>

<p>由于节点少，可以使用相对简单的递归实现方法：</p>

<ul>
<li>每个节点维护一个高度值，用在递归插入后检测子树是否平衡</li>
<li>完成4个旋转方法（参见<a href="http://en.wikipedia.org/wiki/AVL_tree">AVL Tree wikipedia</a>中的示意图）</li>
<li>在递归插入方法中，完成对子树的插入后，检测子树高度差，根据子树的结构特点，做出相应的旋转</li>
<li>旋转后记得更新节点的高度值</li>
</ul>


<p>机试时似乎没有人完全AC这道题，看来代码实现和Debug能力缺乏还是比较普遍的问题。</p>

<p>pat1066源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1066.cpp">请戳</a></p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1067">1067. Sort with Swap(0,*) (25)</a></h2>

<h5>题意</h5>

<p>给定N(&lt;=<code>10^5</code>)以及一个{0,1,…,N-1}的打乱的数列。</p>

<p>定义了一种交换方式：<code>Swap(0,*)</code>，表示将0和任意数进行位置交换。</p>

<p>限定只能使用<code>Swap(0,*)</code>，要求输出最少需要多少次交换操作，来完成整体的排序。</p>

<h5>分析</h5>

<p>很好玩的模拟题，从题目的两个测试数据入手，找到所需要的交换次数的特点：</p>

<p>假设用数组a存储输入的数组，数组的坐标为[0, N - 1]，而元素的所有值也是[0, N - 1]。</p>

<ol>
<li><p>输入的序列中本就在自己位置上的数字，是不用被交换的（比如序列<code>{4, 0, 2, 1, 3}</code>中2就是不用被交换），0除外</p></li>
<li><p>0最终肯定会被放回到0的位置上，但交换过程中，0也可能被提前交换到了0的位置上，此时还有其他数没有处于正确的位置上（参见Sample Input<code>{10 3 5 7 2 6 4 9 0 8 1}</code>的情况）。此时需要多费一步将0和某一个处于不正确位置的数交换位置，来继续排序。</p></li>
<li><p>每次的交换，0其实只是一个过渡作用。实际的交换过程遵循的链式关系如下所述：设定a[x] == b， 而 b != x，则需要将a[x]的值移动到a[b]上，此时a[b] == c, 那么接着又需要将 a[b]的值移动到a[c]上，以此类推，肯定能获得一个循环，且节点数 M 小于等于 N。如果循环中包含了0，那么这个循环中的数排序所需要的交换次数为 M - 1, 如果循环中不包含0，那么首先需要一次交换将0移动到循环链中，此时整个循环链节点数增加了1，于是共需要开销 M + 1 次交换。</p></li>
<li><p>根据3的分析，在2的情况下，0与不同的不在正确位置的数的交换，是不会影响最终的结果的。</p></li>
</ol>


<p>综上所述，用类似dfs或者并查集的思路找到集合中的所有循环链路，记录下他们的大小，即可计算出所需要的交换次数。</p>

<p>pat1067源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1067.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1068">1068. Find More Coins (30)</a></h2>

<h5>题意</h5>

<p>给定 N(&lt;=<code>10^4</code>) 枚硬币和一个价格 M(&lt;=100)。</p>

<p>要求用这 N 枚硬币组合出价格 M，如果有多种组合，输出排序后硬币面值字典序最小的组合，如果没有组合，则输出 No Solution.</p>

<h5>分析</h5>

<p>裸背包问题，相关资料参见dd大神的总结：<a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">《背包问题九讲》</a></p>

<p>按照常规的背包思路，构建10001 * 101 的二维数组f[i][j]，状态f[i][j]表示前i枚硬币能拼凑出的小于等于j的最大值（j这里代表一个价格）。</p>

<p>状态转移方程为：<code>f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + c[i])</code>， 其中c[i]为第i枚硬币的面值，c[i]为排序过的硬币面值数组。</p>

<p>由于最终的输出要求是排序的币值的字典序最小的组合，可以对c[i]做从大到小的排序，并另开一个数组has[i][j]来记录当前状态下，是否有包含c[i]。同时注意，当<code>f[i - 1][j] == f[i - 1][j - c[i]] + c[i]</code>时，采纳当前的c[i]，以满足字典序。</p>

<p>pat1068源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1068.cpp">请戳</a></p>
]]></content>
  </entry>
  
</feed>
