<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: ASM | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.me/tags/asm/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.me/"/>
  <updated>2013-11-07T02:33:21+08:00</updated>
  <id>http://biaobiaoqi.me/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AOP实践：java.lang.instrument的使用]]></title>
    <link href="http://biaobiaoqi.me/blog/2013/09/08/custom-premain-method/"/>
    <updated>2013-09-08T13:01:00+08:00</updated>
    <id>http://biaobiaoqi.me/blog/2013/09/08/custom-premain-method</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>在<a href="https://github.com/biaobiaoqi/rcjp">rcjp</a>项目中，需要调用ASM API（用于字节码处理的开源库）对字节码进行处理，目标是实现对Java程序运行时各种对象的动态跟踪，并进一步分析各个对象之间的关系。在此之前，需要考虑如何获取程序运行的入口。</p>

<p>首先，我考虑到了自定义类加载器（详情见参考资料），即在程序的main入口处，首先加载自定义的类加载器，然后通过反射技术使用这个类加载器加载并调用测试程序。这个方法缺点是：每次都必须先找到测试程序的入口类，而对于有的封装成jar的程序集合，这一点相对比较难控制。</p>

<p>于是，有了这里介绍的方法：通过 <a href="http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html">java.lang.instrument</a> 实现的java agent对象操作字节码，是一种<a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">AOP</a>的方法。</p>

<p>程序中，除了ASMAgent 以外的所有类都是调用ASM API 实现对测试程序中各个对象的构造、方法调用、属性赋值等操作行为的记录（其中对Collection子类的处理着实费了一番心血= =，字节码操作很细节，容易出错）。</p>

<!--more-->


<h2>原理</h2>

<p><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html#N100A7">JVMTI（Java Virtual Machine Tool Interface）</a>是一套本地编程接口集合，它提供了一套『代理』机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的丰富的编程接口，完成很多跟 JVM 相关的功能。</p>

<p>java.lang.instrument 包的实现，也就是基于这种机制的：在 Instrumentation 的实现当中，存在一个 JVMTI 的代理程序，通过调用 JVMTI 当中 Java 类相关的函数来完成 Java 类的动态操作。</p>

<p>Instrumentation 的最大作用就是类定义的动态改变和操作。在 Java SE 5 及其后续版本当中，开发者可以在一个普通 Java 程序（带有 main 函数的 Java 类）运行时，通过 – javaagent参数指定一个特定的 jar 文件（包含 Instrumentation 代理）来启动 Instrumentation 的代理程序。</p>

<h2>步骤</h2>

<h3>1.编写java代理类</h3>

<p>这个类中，premain方法是关键，对比于一般的入口main一样，这里的premain是在main之前执行的。它会告诉JVM如何处理加载上来的java字节码。如下例：</p>

<p>```java
public static void premain(String agentArgs, Instrumentation inst) {</p>

<pre><code>                Trace.BeginTrace(); // it's important for trace files  
        inst.addTransformer(new ASMAgent());  
    }  
</code></pre>

<p>```</p>

<p>值得注意的是，addTransformer实现了对字节码处理的方法的回调。</p>

<p><code>java
inst.addTransformer(new ASMAgent());  
</code></p>

<p>类ASMAgent包含着实现对java字节码处理的方法：transform()。它来自于ClassFileTransformer接口。为了方便，这里将对ClassFileTransformer接口的实现跟ASMAgent类放在了一起。其中classfileBuffer是类文件加载时的原始的字节码，retVal则是经过处理后的字节码。</p>

<p>```java
public byte[] transform(ClassLoader loader, String className,Class&lt;?> classBeingRedefined,</p>

<pre><code>                                    ProtectionDomain protectionDomain,byte[] classfileBuffer)  
        throws IllegalClassFormatException {  
        byte[] retVal = null;  

        if(isInstrumentable(className)){    
            ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);  
            ASMClassAdapter mca = new ASMClassAdapter(cw);   
            ClassReader cr = new ClassReader(classfileBuffer);  
            cr.accept(mca, 0);  
            retVal = cw.toByteArray();  
        }else{  
                retVal = classfileBuffer ;  
            }  

        return retVal;  
}  
</code></pre>

<p>```</p>

<h3>2.打包代理类</h3>

<p>只有合理打包并在manifest文件中记录下相应的键值对之后，才能正常执行premain的内容。
manifest文件中需要添加的键值对是：
<code>
Premain-Class : biaobiaoqi.asm.ASMAgent  
</code></p>

<p>如果对字节码的处理有应用到了其他的类，需要在manifest中增加路径。比如使用到了asm-3.0.jar，则增加如下语句：
<code>
Class-Path: asm-3.0.jar  
</code></p>

<h3>3.执行</h3>

<p>执行测试程序时，添加“-javaagent:代理类的jar[=传入premain的参数]”选项。</p>

<p>比如，对于博主的程序，就是</p>

<p><code>java -javaagent:ASMInstrument.jar   -jar XXXX.jar  xxxx</code></p>

<p>其中ASMInstrument.jar 是第二步中打包的程序，  XXX.jar是需要测试的程序， xxx是XXX.jar 执行时可能的命令行参数。</p>

<p>如果只是执行某.class文件中的类，我们假设是在当前目录下的一个XXXX类，则是：
<code>java -javaagent:ASMInstrument.jar   -cp ./  XXXX xxx</code></p>

<p>其中xxx是可能的命令行参数。</p>

<h3>参考资料</h3>

<ul>
<li><a href="http://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html">《Java SE 6 新特性: Instrumentation 新功能》</a></li>
<li><a href="http://biaobiaoqi.me/blog/2013/09/08/java-class-loader-in-practice/">《Java类加载器编程实践》</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
