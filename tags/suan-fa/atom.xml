<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 算法 | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.io/tags/suan-fa/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.io/"/>
  <updated>2016-04-18T12:51:58+08:00</updated>
  <id>http://biaobiaoqi.github.io/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约80人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//拿到所有作业本后，每周我都需要完成如下过程：
loop in 80+个作业本
    拿起笔，翻开每本作业本；
    在作业本上标记成绩；
    放下笔，关上作业本；
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//邮件查收实验报告
loop in 80+个学生的实验报告邮件；
    保存附件；
    回复已经收到；
end loop

//收集齐所有报告后，开始批改报告
loop in 80+个学生的实验报告
    双击打开报告；
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
    关闭报告；
end loop
</code></pre>

<p>```</p>

<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<p>```</p>

<pre><code>//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
end loop
放下笔

//录入成绩
loop in 80+个作业本
    翻开作业本，查看成绩
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
    关闭作业本；
end loop
</code></pre>

<p>```</p>

<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在A+、A、A- 这几个分数上，其他分数如B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的B+、B、B-等分入到Else作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据[1, n]的索引就可以快速检索到了。</p>

<p>```</p>

<pre><code>//预处理
给作业本建索引

//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
    将作业按照评分放入 A+、A、A-和Else 这四个堆中
end loop
放下笔

//录入成绩
loop in A+、 A、 A-、 Else 这四个作业堆
    loop in 作业堆
        if 作业堆 == Else 
            翻开作业本；
            查看成绩；
            关上作业本；
        end if
        根据索引查找到学生；
        输入成绩;
    end loop
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建FTP；使用工具（比如 Acrobat）将所有报告连接成单个pdf文件。</p>

<p>```</p>

<pre><code>//预处理
FTP收集报告
使用Acrobat 将所有pdf报告连接成一个汇总报告

//批改报告和录入成绩
双击打开汇总报告；
loop in 80+个学生的实验报告
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
end loop
关闭汇总报告；
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用pdf和姓名加学号的命名提交作业，也一定会有学生会使用doc格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在wiki上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证2个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java实现：</p>

<p>```</p>

<pre><code>int temp = 0;
for (int i = a.length - 1; i &gt; 0; --i) {
  for (int j = 0; j &lt; i; ++j) {
    if (a[j + 1] &lt; a[j]) {
      temp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = temp;
    }
  }
}
</code></pre>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for(int index=1;index&lt;data.length;index++){</p>

<pre><code>Comparable key = data[index];  
int position = index;  
//shift larger values to the right  
while(position&gt;0&amp;&amp;data[position-1].compareTo(key)&gt;0){  
    data[position] = data[position-1];  
    position--;
}  
data[position]=key;  
</code></pre>

<p>}   <br/>
```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for (int index = 0; index &lt; array.length - 1; index++) {</p>

<pre><code>min = index;
for (int time = index + 1; time &lt; array.length; time++) {
    if (array[time].compareTo(array[min]) &lt; 0) {
        min = time;
    }
}
temp = array[index];
array[index] = array[min];
array[min] = temp;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在[0]和[3]之间，[0]的3被交换到[2]的3之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为pivot，代码实现中取第一个元素为pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort (int[] input){</p>

<pre><code>  sort (input, 0, input.length-1);
</code></pre>

<p>}</p>

<p>private void sort(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>if (highIndex&lt;=lowIndex){
    return;
}

int partIndex=partition (input, lowIndex, highIndex);

sort (input, lowIndex, partIndex-1);
sort (input, partIndex+1, highIndex);
</code></pre>

<p>}</p>

<p>private int partition(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>int i=lowIndex;
int pivotIndex=lowIndex;
int j=highIndex+1;

while (true){
    while (less(input[++i], input[pivotIndex])){
        if (i==highIndex) break;
    }

    while (less (input[pivotIndex], input[--j])){
        if (j==lowIndex) break;
    }

    if (i&gt;=j) break;

    exchange(input, i, j);
}

exchange(input, pivotIndex, j);

return j;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取pivot不够科学，在有序或者逆序的情况下会产生n<sup>2的时间开销。</sup></sup></li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的3会被交换到10和11的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对pivot的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的K个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort(Integer[] list) {</p>

<pre><code>if (list.length == 0) {
    System.out.println("");
} else {
    Integer[] tmpList = new Integer[list.length];
    mergeSort(list, 0, list.length - 1, tmpList);
}
</code></pre>

<p>}</p>

<p>public void mergeSort(Integer[] list, int leftPos, int rightPos,</p>

<pre><code>    Integer[] tmpList) {
if (leftPos &gt;= rightPos)
    return;

int center = (leftPos + rightPos) / 2;
mergeSort(list, leftPos, center, tmpList);
mergeSort(list, center + 1, rightPos, tmpList);
merge(list, leftPos, center, rightPos, tmpList);
</code></pre>

<p>}</p>

<p>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,</p>

<pre><code>    Integer[] tmpList) {
int leftIndex  = leftPos;
int rightIndex = leftEnd + 1;
int index = leftIndex;

while (leftIndex &lt;= leftEnd &amp;&amp; rightIndex &lt;= rightEnd) {
    if (list[leftIndex] &lt;= list[rightIndex]) {
        tmpList[index++] = list[leftIndex++];
    } else {
        tmpList[index++] = list[rightIndex++];
    }
}

while (leftIndex &lt;= leftEnd) {
    tmpList[index++] = list[leftIndex++];
}
while (rightIndex &lt;= rightEnd) {
    tmpList[index++] = list[rightIndex++];
}

for (int i = leftPos; i &lt;= rightEnd; i ++) {
    list[i] = tmpList[i];
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java的java.util.Arrays中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java实现</p>

<p>```
public int leftChild(int n) {</p>

<pre><code>return 2*n + 1;
</code></pre>

<p>}</p>

<p>public void percolateDown(int[] list, int n, int length) {</p>

<pre><code>int tmp;
int child;

for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
    child = leftChild(n);

    if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1]) {
        child ++;
    }

    if (tmp &lt; list[child]) {
        list[n] = list[child];
    }else {
        break;
    }
}

list[n] = tmp;
</code></pre>

<p>}</p>

<p>public void sort(int[] list) {</p>

<pre><code>for (int i = list.length/2; i &gt;= 0; i --) {
    percolateDown(list, i, list.length);
}

for (int i = list.length - 1; i &gt; 0; i --) {
    int tmp = list[i];
    list[i] = list[0];
    list[0] = tmp;

    percolateDown(list, 0, i);
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个27后，原来在后面的27被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并1中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N个数组的排序，有N!种可能结果，我们需要在N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为1/2和1/2，也就一次比较中a&lt;b的概率和a>b的概率一样，如果能保证一这一点，就能保证最优下界，也就是log2(N!)，这个值近似于NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1069 - 1072 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072/"/>
    <updated>2013-11-07T00:30:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/11/07/pat-1069-pat-1072</id>
    <content type="html"><![CDATA[<p>来源是 2013 年 11 月 2 日的PAT测试。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1069">1069. The Black Hole of Numbers (20)</a></h2>

<h5>题意</h5>

<p>给出一个四位数比如6767，将它按照每位从小到大(6677)和从大到小(7766)充足，得到两个新四位数，这两者相减将得到一个新的四位数。再按照一样的处理方式处理得出的四位数</p>

<p>```
7766 - 6677 = 1089
9810 - 0189 = 9621
9621 - 1269 = 8352
8532 - 2358 = 6174
7641 - 1467 = 6174</p>

<p>```</p>

<p>最终将得到一个『黑洞数』：6174。</p>

<p>题目给出一个四位数，要求输出它演变出『黑洞数』的过程。</p>

<!--more-->


<h5>分析</h5>

<p>简单模拟题，需要留心两个特殊情况的处理：<code>6174</code>，<code>xxxx</code>。</p>

<p>熟练掌握 C 的基本函数也能缩短代码编写，比如<code>atoi()</code> 和 <code>sprintf()</code>， 由于<code>itoa()</code>是依赖于Windows的，这里不推荐使用。</p>

<p>pat1069源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1069.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1070">1070. Mooncake (25)</a></h2>

<h5>题意</h5>

<p>给出月饼市场的需求 D&lt;= 500 （按重量计算），给出现有 N &lt;= 1000 种月饼，每种月饼有一定数量的储备（按重量计算）以及这些储备所对应的价格，求一个出售月饼的方式，在容量D的市场里，获得最多的销售额。</p>

<h5>分析</h5>

<p>简单的贪心问题。贪心的规则是月饼的单价。注意有一个坑：每种月饼的存货量也需要用<code>double</code>来做存储。</p>

<p>pat1070源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1070.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1071">1071. Speech Patterns (25)</a></h2>

<h5>题意</h5>

<p>给出一个长度不超过 1048576 的字符串。把所有连续的字母或者数字（[0-9 A-Z a-z]）试做单词，且忽略大小写，求其中最高频的单词。</p>

<h5>分析</h5>

<p>使用map&lt;string, int>做存储，统计出现次数即可。</p>

<p>有些细节需要注意：</p>

<ul>
<li>使用<code>getline(cin, str)</code>获取正行数据</li>
<li>使用<code>transform(str.begin(), str.end(), str.begin(), ::tolower);</code>将字符串转换成小写</li>
<li>遍历字符串获取单词时，注意特殊条件。比如以非字符数字开头的字符串，以字符数字结尾的字符串等。</li>
</ul>


<p>pat1071源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1071.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1072">1072. Gas Station (30)</a></h2>

<h5>题意</h5>

<p>给出一个图，其中有 N &lt;= 10<sup>3</sup> 个节点是居民房，M &lt;= 10 个节点是计划建造加油站的候选点。给出加油站所能服务的最远距离 D。要求计算出合适的位置建造加油站，满足如下优先级条件：</p>

<ol>
<li>所有居民房必须在加油站的服务距离内。</li>
<li>所有居民房中距离加油站的最近的居民房与加油站之间的距离是最远的。（大概是安全方面的考虑，加油站要离居民区远一点）</li>
<li>所有房间距离加油站的最小距离的总和最小。（节约居民加油的总体成本）</li>
<li>同等条件下，序号越小的加油站优先。</li>
</ol>


<h5>分析</h5>

<p>实际上是求加油站到所有点的最短路径的问题，使用Dijsktra可以满足。</p>

<p>另外，需要考虑求最短路径的过程中是否要将其他加油站所构建的路径算入在内。从背景上看，加油站应该在公路边修建，故加油站之间以及居民房和加油站之间都是存在路径的，从给出的数据来看，存在两个加油站之间的路径。所以，计算最短路径时，是需要将所有加油站的节点也计算在内的。</p>

<p>pat1072源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1072.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PAT 1065 - 1068 题解]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/10/08/pat-1065-pat-1068/"/>
    <updated>2013-10-08T13:46:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/10/08/pat-1065-pat-1068</id>
    <content type="html"><![CDATA[<p>这次的题目来源是2013年10月7日下午的浙大计算机研究生招生机试题。</p>

<p>这次题目的难度，按姥姥的说法是：『比普通的PAT要难了0.5个点。我是把自己的题目从1.0到5.0以0.5的间距分难度级别的，PAT(A)难度一般在1.5-4.5之间，保研考试一般在2.0-5.0之间。PAT(B)大概是1.0-2.5的难度。』。</p>

<p>个人认为，其中1066模拟AVL插入的实现有些细节容易弄错，而1068只要会简单的DP，也就没有问题了，1065和1066都还是很简单的实现。</p>

<p>下面是各个题的分析（PAT advanced level本人实现的全部源码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a>）。</p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1065">1065. A+B and C (64bit) (20)</a></h2>

<h5>题意</h5>

<p>输入三个数a，b，c，取值范围是 [<code>-2^63</code>, <code>2^63</code>]，要求判断<code>a + b &lt; c</code> 是否为真。</p>

<h5>分析</h5>

<p>很简单的签到题，想到两种方法：一是用Java的Big Decimal实现（应该不会超时吧-,-），二是对a+b造成的long long溢出的情况做特殊处理。</p>

<p>对于分情况的实现方式，实际上也就两种特殊情况，即a，b同号且两者之和溢出了（绝对值超过了2<sup>63）。此时两者之和与c的值的相对关系也是确定的。</sup></p>

<ul>
<li><code>a &lt; 0 &amp;&amp; b &lt; 0 &amp;&amp; a + b &gt;= 0</code>: a + b 必小于c</li>
<li><code>a &gt; 0 &amp;&amp; b &gt; 0 &amp;&amp; a + b &lt;= 0</code>: a + b 必大于c</li>
</ul>


<p>另在98看见有大神说可以用long double水过去-,-.</p>

<p>pat1065源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1065.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1066">1066. Root of AVL Tree (25)</a></h2>

<h5>题意</h5>

<p>实现<a href="http://en.wikipedia.org/wiki/AVL_tree">AVL树</a>的插入方法，给定N(&lt;=20)个数，要求输出依次插入后的AVL树的根。</p>

<h5>分析</h5>

<p>由于节点少，可以使用相对简单的递归实现方法：</p>

<ul>
<li>每个节点维护一个高度值，用在递归插入后检测子树是否平衡</li>
<li>完成4个旋转方法（参见<a href="http://en.wikipedia.org/wiki/AVL_tree">AVL Tree wikipedia</a>中的示意图）</li>
<li>在递归插入方法中，完成对子树的插入后，检测子树高度差，根据子树的结构特点，做出相应的旋转</li>
<li>旋转后记得更新节点的高度值</li>
</ul>


<p>机试时似乎没有人完全AC这道题，看来代码实现和Debug能力缺乏还是比较普遍的问题。</p>

<p>pat1066源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1066.cpp">请戳</a></p>

<!--more-->


<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1067">1067. Sort with Swap(0,*) (25)</a></h2>

<h5>题意</h5>

<p>给定N(&lt;=<code>10^5</code>)以及一个{0,1,…,N-1}的打乱的数列。</p>

<p>定义了一种交换方式：<code>Swap(0,*)</code>，表示将0和任意数进行位置交换。</p>

<p>限定只能使用<code>Swap(0,*)</code>，要求输出最少需要多少次交换操作，来完成整体的排序。</p>

<h5>分析</h5>

<p>很好玩的模拟题，从题目的两个测试数据入手，找到所需要的交换次数的特点：</p>

<p>假设用数组a存储输入的数组，数组的坐标为[0, N - 1]，而元素的所有值也是[0, N - 1]。</p>

<ol>
<li><p>输入的序列中本就在自己位置上的数字，是不用被交换的（比如序列<code>{4, 0, 2, 1, 3}</code>中2就是不用被交换），0除外</p></li>
<li><p>0最终肯定会被放回到0的位置上，但交换过程中，0也可能被提前交换到了0的位置上，此时还有其他数没有处于正确的位置上（参见Sample Input<code>{10 3 5 7 2 6 4 9 0 8 1}</code>的情况）。此时需要多费一步将0和某一个处于不正确位置的数交换位置，来继续排序。</p></li>
<li><p>每次的交换，0其实只是一个过渡作用。实际的交换过程遵循的链式关系如下所述：设定a[x] == b， 而 b != x，则需要将a[x]的值移动到a[b]上，此时a[b] == c, 那么接着又需要将 a[b]的值移动到a[c]上，以此类推，肯定能获得一个循环，且节点数 M 小于等于 N。如果循环中包含了0，那么这个循环中的数排序所需要的交换次数为 M - 1, 如果循环中不包含0，那么首先需要一次交换将0移动到循环链中，此时整个循环链节点数增加了1，于是共需要开销 M + 1 次交换。</p></li>
<li><p>根据3的分析，在2的情况下，0与不同的不在正确位置的数的交换，是不会影响最终的结果的。</p></li>
</ol>


<p>综上所述，用类似dfs或者并查集的思路找到集合中的所有循环链路，记录下他们的大小，即可计算出所需要的交换次数。</p>

<p>pat1067源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1067.cpp">请戳</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1068">1068. Find More Coins (30)</a></h2>

<h5>题意</h5>

<p>给定 N(&lt;=<code>10^4</code>) 枚硬币和一个价格 M(&lt;=100)。</p>

<p>要求用这 N 枚硬币组合出价格 M，如果有多种组合，输出排序后硬币面值字典序最小的组合，如果没有组合，则输出 No Solution.</p>

<h5>分析</h5>

<p>裸背包问题，相关资料参见dd大神的总结：<a href="http://cuitianyi.com/blog/%E3%80%8A%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E4%B9%9D%E8%AE%B2%E3%80%8B2-0-alpha1/">《背包问题九讲》</a></p>

<p>按照常规的背包思路，构建10001 * 101 的二维数组f[i][j]，状态f[i][j]表示前i枚硬币能拼凑出的小于等于j的最大值（j这里代表一个价格）。</p>

<p>状态转移方程为：<code>f[i][j] = max(f[i - 1][j], f[i - 1][j - c[i]] + c[i])</code>， 其中c[i]为第i枚硬币的面值，c[i]为排序过的硬币面值数组。</p>

<p>由于最终的输出要求是排序的币值的字典序最小的组合，可以对c[i]做从大到小的排序，并另开一个数组has[i][j]来记录当前状态下，是否有包含c[i]。同时注意，当<code>f[i - 1][j] == f[i - 1][j - c[i]] + c[i]</code>时，采纳当前的c[i]，以满足字典序。</p>

<p>pat1068源码:<a href="https://github.com/biaobiaoqi/CPractice/blob/master/PAT/advancedlevel/APAT1068.cpp">请戳</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[《改变未来的九大算法》]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2013/10/03/nine-algorithms-that-changed-the-future/"/>
    <updated>2013-10-03T13:19:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2013/10/03/nine-algorithms-that-changed-the-future</id>
    <content type="html"><![CDATA[<h2>不要在意那些细节</h2>

<p>这是一本关于计算机世界的科普读物。豆瓣链接：<a href="http://book.douban.com/subject/24529132/">请戳</a>。</p>

<p>非常推荐刚接触计算机的朋友花上三五小时将全书通读一遍，没有技术细节，没有公式证明，它会告诉作者挑选出的九大算法出现的缘由和发展的过程。这些不关乎实现细节的思想概括，更能体现算法在整个领域中的存在的原因。它们不再是冷冰冰的算法过程，这是阅读大多数的书籍、教材所难以获得的。</p>

<p>至于我的推荐原因，如下全文。</p>

<!--more-->


<h3>课程学习之弊</h3>

<p>大二大三的那两年，在学校上过了网络、操作系统、数据库、算法设计等诸多计算机领域的基础必修课程。由于生性愚钝加之令人头大的砖头书的体系化、理论化，对于知识的掌握顶多处于知其然却不知其所以然的程度。在这种情况下，学习就退化为了填鸭式的记忆。比如我记得RSA的公钥加密流程，却无法理解为何要套用这么一大堆的数学方法来得到如此神奇的效果，比如，我知道数据库有一套日志机制，却不知道它是如何与其他的组件共同构建起一个系统的……没有来龙去脉，就没有对技术发展的感知，没有对技术本质的理解和认识。</p>

<p>经过了四年多的摸爬滚打，到现在对这些基础知识的认识自然远好于当年上课的理解水平，不是因为我在反复的学习课程内容，而是从实践中获得了新的认识。</p>

<h3>从生活出发</h3>

<p>大多数人的思维习惯，倾向于从已知的事物中衍生对新事物的认识，这是一种类推。而高校的大多数教材和教授方式较少考虑到这一点，一种简单粗暴的直入主题的方式被大量的使用，排斥了知识的前因后果，技术的来龙去脉，剩下的只是新体系本身。这增加了学习曲线的入门坡度。</p>

<blockquote><p>理论是灰色的，生活之树常青</p></blockquote>

<p>《改变未来的九大算法》是对歌德这句话的良好实践。</p>

<!--more-->


<p>比如在阐述公钥加密机制时，作者从生活中的寄信讲起，一步步类比到计算机的通信上，并用染料配色的方式举例了迪菲赫尔曼机制。生动形象的描述了算法的原理和来由。</p>

<h3>抛开细节实现</h3>

<p>过往的教材一旦陷入对某些实现细节的阐释，就失去了对全局上下文的把握。就像镜头对焦到了一个点上，造成了周边景物的模糊化效果。</p>

<p>《改变未来的九大算法》全书很少涉及到技术的实现细节，这正是它的优势所在。比如数据库的一致性章节，从一个银行转账的实例讲起，通过所面临的一系列问题的解决方案的描述，让人对数据库的整体实现有了全局的把握。在理解的前提下，更深入的学习也变得更有动力和方向。</p>

<p>奈何自己已经过了朦朦胧胧的那几年，在此将本书强烈推荐给初涉计算机领域的朋友们。当然，其他人粗读一遍，也是对自己知识体系的一次小梳理啦;)。</p>
]]></content>
  </entry>
  
</feed>
