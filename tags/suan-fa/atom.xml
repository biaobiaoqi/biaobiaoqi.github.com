<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: 算法 | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.io/tags/suan-fa/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.io/"/>
  <updated>2016-04-19T00:27:46+08:00</updated>
  <id>http://biaobiaoqi.github.io/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约80人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//拿到所有作业本后，每周我都需要完成如下过程：
loop in 80+个作业本
    拿起笔，翻开每本作业本；
    在作业本上标记成绩；
    放下笔，关上作业本；
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//邮件查收实验报告
loop in 80+个学生的实验报告邮件；
    保存附件；
    回复已经收到；
end loop

//收集齐所有报告后，开始批改报告
loop in 80+个学生的实验报告
    双击打开报告；
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
    关闭报告；
end loop
</code></pre>

<p>```</p>

<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<p>```</p>

<pre><code>//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
end loop
放下笔

//录入成绩
loop in 80+个作业本
    翻开作业本，查看成绩
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
    关闭作业本；
end loop
</code></pre>

<p>```</p>

<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在A+、A、A- 这几个分数上，其他分数如B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的B+、B、B-等分入到Else作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据[1, n]的索引就可以快速检索到了。</p>

<p>```</p>

<pre><code>//预处理
给作业本建索引

//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
    将作业按照评分放入 A+、A、A-和Else 这四个堆中
end loop
放下笔

//录入成绩
loop in A+、 A、 A-、 Else 这四个作业堆
    loop in 作业堆
        if 作业堆 == Else 
            翻开作业本；
            查看成绩；
            关上作业本；
        end if
        根据索引查找到学生；
        输入成绩;
    end loop
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建FTP；使用工具（比如 Acrobat）将所有报告连接成单个pdf文件。</p>

<p>```</p>

<pre><code>//预处理
FTP收集报告
使用Acrobat 将所有pdf报告连接成一个汇总报告

//批改报告和录入成绩
双击打开汇总报告；
loop in 80+个学生的实验报告
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
end loop
关闭汇总报告；
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用pdf和姓名加学号的命名提交作业，也一定会有学生会使用doc格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约80人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//拿到所有作业本后，每周我都需要完成如下过程：
loop in 80+个作业本
    拿起笔，翻开每本作业本；
    在作业本上标记成绩；
    放下笔，关上作业本；
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//邮件查收实验报告
loop in 80+个学生的实验报告邮件；
    保存附件；
    回复已经收到；
end loop

//收集齐所有报告后，开始批改报告
loop in 80+个学生的实验报告
    双击打开报告；
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
    关闭报告；
end loop
</code></pre>

<p>```</p>

<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<p>```</p>

<pre><code>//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
end loop
放下笔

//录入成绩
loop in 80+个作业本
    翻开作业本，查看成绩
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
    关闭作业本；
end loop
</code></pre>

<p>```</p>

<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在A+、A、A- 这几个分数上，其他分数如B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的B+、B、B-等分入到Else作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据[1, n]的索引就可以快速检索到了。</p>

<p>```</p>

<pre><code>//预处理
给作业本建索引

//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
    将作业按照评分放入 A+、A、A-和Else 这四个堆中
end loop
放下笔

//录入成绩
loop in A+、 A、 A-、 Else 这四个作业堆
    loop in 作业堆
        if 作业堆 == Else 
            翻开作业本；
            查看成绩；
            关上作业本；
        end if
        根据索引查找到学生；
        输入成绩;
    end loop
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建FTP；使用工具（比如 Acrobat）将所有报告连接成单个pdf文件。</p>

<p>```</p>

<pre><code>//预处理
FTP收集报告
使用Acrobat 将所有pdf报告连接成一个汇总报告

//批改报告和录入成绩
双击打开汇总报告；
loop in 80+个学生的实验报告
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
end loop
关闭汇总报告；
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用pdf和姓名加学号的命名提交作业，也一定会有学生会使用doc格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约80人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//拿到所有作业本后，每周我都需要完成如下过程：
loop in 80+个作业本
    拿起笔，翻开每本作业本；
    在作业本上标记成绩；
    放下笔，关上作业本；
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>```</p>

<pre><code>//邮件查收实验报告
loop in 80+个学生的实验报告邮件；
    保存附件；
    回复已经收到；
end loop

//收集齐所有报告后，开始批改报告
loop in 80+个学生的实验报告
    双击打开报告；
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
    关闭报告；
end loop
</code></pre>

<p>```</p>

<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<p>```</p>

<pre><code>//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
end loop
放下笔

//录入成绩
loop in 80+个作业本
    翻开作业本，查看成绩
    在成绩记录表格上上CTRL+F 查找到对应的学生；
    输入成绩;
    关闭作业本；
end loop
</code></pre>

<p>```</p>

<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在A+、A、A- 这几个分数上，其他分数如B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的B+、B、B-等分入到Else作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据[1, n]的索引就可以快速检索到了。</p>

<p>```</p>

<pre><code>//预处理
给作业本建索引

//改作业
拿起笔
loop in 80+个作业本
    翻开作业本；
    在作业本上标记成绩；
    关闭作业本；
    将作业按照评分放入 A+、A、A-和Else 这四个堆中
end loop
放下笔

//录入成绩
loop in A+、 A、 A-、 Else 这四个作业堆
    loop in 作业堆
        if 作业堆 == Else 
            翻开作业本；
            查看成绩；
            关上作业本；
        end if
        根据索引查找到学生；
        输入成绩;
    end loop
end loop
</code></pre>

<p>```</p>

<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建FTP；使用工具（比如 Acrobat）将所有报告连接成单个pdf文件。</p>

<p>```</p>

<pre><code>//预处理
FTP收集报告
使用Acrobat 将所有pdf报告连接成一个汇总报告

//批改报告和录入成绩
双击打开汇总报告；
loop in 80+个学生的实验报告
    浏览评分；
    在成绩记录表格上CTRL+F 查找到对应的学生；
    输入成绩；
end loop
关闭汇总报告；
</code></pre>

<p>```</p>

<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用pdf和姓名加学号的命名提交作业，也一定会有学生会使用doc格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在wiki上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证2个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java实现：</p>

<p>```</p>

<pre><code>int temp = 0;
for (int i = a.length - 1; i &gt; 0; --i) {
  for (int j = 0; j &lt; i; ++j) {
    if (a[j + 1] &lt; a[j]) {
      temp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = temp;
    }
  }
}
</code></pre>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for(int index=1;index&lt;data.length;index++){</p>

<pre><code>Comparable key = data[index];  
int position = index;  
//shift larger values to the right  
while(position&gt;0&amp;&amp;data[position-1].compareTo(key)&gt;0){  
    data[position] = data[position-1];  
    position--;
}  
data[position]=key;  
</code></pre>

<p>}   <br/>
```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for (int index = 0; index &lt; array.length - 1; index++) {</p>

<pre><code>min = index;
for (int time = index + 1; time &lt; array.length; time++) {
    if (array[time].compareTo(array[min]) &lt; 0) {
        min = time;
    }
}
temp = array[index];
array[index] = array[min];
array[min] = temp;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在[0]和[3]之间，[0]的3被交换到[2]的3之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为pivot，代码实现中取第一个元素为pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort (int[] input){</p>

<pre><code>  sort (input, 0, input.length-1);
</code></pre>

<p>}</p>

<p>private void sort(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>if (highIndex&lt;=lowIndex){
    return;
}

int partIndex=partition (input, lowIndex, highIndex);

sort (input, lowIndex, partIndex-1);
sort (input, partIndex+1, highIndex);
</code></pre>

<p>}</p>

<p>private int partition(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>int i=lowIndex;
int pivotIndex=lowIndex;
int j=highIndex+1;

while (true){
    while (less(input[++i], input[pivotIndex])){
        if (i==highIndex) break;
    }

    while (less (input[pivotIndex], input[--j])){
        if (j==lowIndex) break;
    }

    if (i&gt;=j) break;

    exchange(input, i, j);
}

exchange(input, pivotIndex, j);

return j;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取pivot不够科学，在有序或者逆序的情况下会产生n<sup>2的时间开销。</sup></sup></li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的3会被交换到10和11的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对pivot的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的K个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort(Integer[] list) {</p>

<pre><code>if (list.length == 0) {
    System.out.println("");
} else {
    Integer[] tmpList = new Integer[list.length];
    mergeSort(list, 0, list.length - 1, tmpList);
}
</code></pre>

<p>}</p>

<p>public void mergeSort(Integer[] list, int leftPos, int rightPos,</p>

<pre><code>    Integer[] tmpList) {
if (leftPos &gt;= rightPos)
    return;

int center = (leftPos + rightPos) / 2;
mergeSort(list, leftPos, center, tmpList);
mergeSort(list, center + 1, rightPos, tmpList);
merge(list, leftPos, center, rightPos, tmpList);
</code></pre>

<p>}</p>

<p>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,</p>

<pre><code>    Integer[] tmpList) {
int leftIndex  = leftPos;
int rightIndex = leftEnd + 1;
int index = leftIndex;

while (leftIndex &lt;= leftEnd &amp;&amp; rightIndex &lt;= rightEnd) {
    if (list[leftIndex] &lt;= list[rightIndex]) {
        tmpList[index++] = list[leftIndex++];
    } else {
        tmpList[index++] = list[rightIndex++];
    }
}

while (leftIndex &lt;= leftEnd) {
    tmpList[index++] = list[leftIndex++];
}
while (rightIndex &lt;= rightEnd) {
    tmpList[index++] = list[rightIndex++];
}

for (int i = leftPos; i &lt;= rightEnd; i ++) {
    list[i] = tmpList[i];
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java的java.util.Arrays中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java实现</p>

<p>```
public int leftChild(int n) {</p>

<pre><code>return 2*n + 1;
</code></pre>

<p>}</p>

<p>public void percolateDown(int[] list, int n, int length) {</p>

<pre><code>int tmp;
int child;

for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
    child = leftChild(n);

    if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1]) {
        child ++;
    }

    if (tmp &lt; list[child]) {
        list[n] = list[child];
    }else {
        break;
    }
}

list[n] = tmp;
</code></pre>

<p>}</p>

<p>public void sort(int[] list) {</p>

<pre><code>for (int i = list.length/2; i &gt;= 0; i --) {
    percolateDown(list, i, list.length);
}

for (int i = list.length - 1; i &gt; 0; i --) {
    int tmp = list[i];
    list[i] = list[0];
    list[0] = tmp;

    percolateDown(list, 0, i);
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个27后，原来在后面的27被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并1中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N个数组的排序，有N!种可能结果，我们需要在N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为1/2和1/2，也就一次比较中a&lt;b的概率和a>b的概率一样，如果能保证一这一点，就能保证最优下界，也就是log2(N!)，这个值近似于NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在wiki上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证2个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java实现：</p>

<p>```</p>

<pre><code>int temp = 0;
for (int i = a.length - 1; i &gt; 0; --i) {
  for (int j = 0; j &lt; i; ++j) {
    if (a[j + 1] &lt; a[j]) {
      temp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = temp;
    }
  }
}
</code></pre>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for(int index=1;index&lt;data.length;index++){</p>

<pre><code>Comparable key = data[index];  
int position = index;  
//shift larger values to the right  
while(position&gt;0&amp;&amp;data[position-1].compareTo(key)&gt;0){  
    data[position] = data[position-1];  
    position--;
}  
data[position]=key;  
</code></pre>

<p>}   <br/>
```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for (int index = 0; index &lt; array.length - 1; index++) {</p>

<pre><code>min = index;
for (int time = index + 1; time &lt; array.length; time++) {
    if (array[time].compareTo(array[min]) &lt; 0) {
        min = time;
    }
}
temp = array[index];
array[index] = array[min];
array[min] = temp;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在[0]和[3]之间，[0]的3被交换到[2]的3之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为pivot，代码实现中取第一个元素为pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort (int[] input){</p>

<pre><code>  sort (input, 0, input.length-1);
</code></pre>

<p>}</p>

<p>private void sort(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>if (highIndex&lt;=lowIndex){
    return;
}

int partIndex=partition (input, lowIndex, highIndex);

sort (input, lowIndex, partIndex-1);
sort (input, partIndex+1, highIndex);
</code></pre>

<p>}</p>

<p>private int partition(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>int i=lowIndex;
int pivotIndex=lowIndex;
int j=highIndex+1;

while (true){
    while (less(input[++i], input[pivotIndex])){
        if (i==highIndex) break;
    }

    while (less (input[pivotIndex], input[--j])){
        if (j==lowIndex) break;
    }

    if (i&gt;=j) break;

    exchange(input, i, j);
}

exchange(input, pivotIndex, j);

return j;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取pivot不够科学，在有序或者逆序的情况下会产生n<sup>2的时间开销。</sup></sup></li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的3会被交换到10和11的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对pivot的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的K个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort(Integer[] list) {</p>

<pre><code>if (list.length == 0) {
    System.out.println("");
} else {
    Integer[] tmpList = new Integer[list.length];
    mergeSort(list, 0, list.length - 1, tmpList);
}
</code></pre>

<p>}</p>

<p>public void mergeSort(Integer[] list, int leftPos, int rightPos,</p>

<pre><code>    Integer[] tmpList) {
if (leftPos &gt;= rightPos)
    return;

int center = (leftPos + rightPos) / 2;
mergeSort(list, leftPos, center, tmpList);
mergeSort(list, center + 1, rightPos, tmpList);
merge(list, leftPos, center, rightPos, tmpList);
</code></pre>

<p>}</p>

<p>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,</p>

<pre><code>    Integer[] tmpList) {
int leftIndex  = leftPos;
int rightIndex = leftEnd + 1;
int index = leftIndex;

while (leftIndex &lt;= leftEnd &amp;&amp; rightIndex &lt;= rightEnd) {
    if (list[leftIndex] &lt;= list[rightIndex]) {
        tmpList[index++] = list[leftIndex++];
    } else {
        tmpList[index++] = list[rightIndex++];
    }
}

while (leftIndex &lt;= leftEnd) {
    tmpList[index++] = list[leftIndex++];
}
while (rightIndex &lt;= rightEnd) {
    tmpList[index++] = list[rightIndex++];
}

for (int i = leftPos; i &lt;= rightEnd; i ++) {
    list[i] = tmpList[i];
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java的java.util.Arrays中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java实现</p>

<p>```
public int leftChild(int n) {</p>

<pre><code>return 2*n + 1;
</code></pre>

<p>}</p>

<p>public void percolateDown(int[] list, int n, int length) {</p>

<pre><code>int tmp;
int child;

for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
    child = leftChild(n);

    if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1]) {
        child ++;
    }

    if (tmp &lt; list[child]) {
        list[n] = list[child];
    }else {
        break;
    }
}

list[n] = tmp;
</code></pre>

<p>}</p>

<p>public void sort(int[] list) {</p>

<pre><code>for (int i = list.length/2; i &gt;= 0; i --) {
    percolateDown(list, i, list.length);
}

for (int i = list.length - 1; i &gt; 0; i --) {
    int tmp = list[i];
    list[i] = list[0];
    list[0] = tmp;

    percolateDown(list, 0, i);
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个27后，原来在后面的27被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并1中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N个数组的排序，有N!种可能结果，我们需要在N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为1/2和1/2，也就一次比较中a&lt;b的概率和a>b的概率一样，如果能保证一这一点，就能保证最优下界，也就是log2(N!)，这个值近似于NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
