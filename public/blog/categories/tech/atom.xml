<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tech | Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.io/blog/categories/tech/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.io/"/>
  <updated>2017-02-28T19:27:43+08:00</updated>
  <id>http://biaobiaoqi.github.io/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在wiki上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证2个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java实现：</p>

<p>```</p>

<pre><code>int temp = 0;
for (int i = a.length - 1; i &gt; 0; --i) {
  for (int j = 0; j &lt; i; ++j) {
    if (a[j + 1] &lt; a[j]) {
      temp = a[j];
      a[j] = a[j + 1];
      a[j + 1] = temp;
    }
  }
}
</code></pre>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for(int index=1;index&lt;data.length;index++){</p>

<pre><code>Comparable key = data[index];  
int position = index;  
//shift larger values to the right  
while(position&gt;0&amp;&amp;data[position-1].compareTo(key)&gt;0){  
    data[position] = data[position-1];  
    position--;
}  
data[position]=key;  
</code></pre>

<p>}   <br/>
```</p>

<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java实现</p>

<p>```
for (int index = 0; index &lt; array.length - 1; index++) {</p>

<pre><code>min = index;
for (int time = index + 1; time &lt; array.length; time++) {
    if (array[time].compareTo(array[min]) &lt; 0) {
        min = time;
    }
}
temp = array[index];
array[index] = array[min];
array[min] = temp;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在[0]和[3]之间，[0]的3被交换到[2]的3之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为pivot，代码实现中取第一个元素为pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort (int[] input){</p>

<pre><code>  sort (input, 0, input.length-1);
</code></pre>

<p>}</p>

<p>private void sort(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>if (highIndex&lt;=lowIndex){
    return;
}

int partIndex=partition (input, lowIndex, highIndex);

sort (input, lowIndex, partIndex-1);
sort (input, partIndex+1, highIndex);
</code></pre>

<p>}</p>

<p>private int partition(int[] input, int lowIndex, int highIndex) {</p>

<pre><code>int i=lowIndex;
int pivotIndex=lowIndex;
int j=highIndex+1;

while (true){
    while (less(input[++i], input[pivotIndex])){
        if (i==highIndex) break;
    }

    while (less (input[pivotIndex], input[--j])){
        if (j==lowIndex) break;
    }

    if (i&gt;=j) break;

    exchange(input, i, j);
}

exchange(input, pivotIndex, j);

return j;
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取pivot不够科学，在有序或者逆序的情况下会产生n<sup>2的时间开销。</sup></sup></li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共O(n) ，需要辅助空间O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的3会被交换到10和11的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对pivot的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的K个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java实现</p>

<p>```
public void sort(Integer[] list) {</p>

<pre><code>if (list.length == 0) {
    System.out.println("");
} else {
    Integer[] tmpList = new Integer[list.length];
    mergeSort(list, 0, list.length - 1, tmpList);
}
</code></pre>

<p>}</p>

<p>public void mergeSort(Integer[] list, int leftPos, int rightPos,</p>

<pre><code>    Integer[] tmpList) {
if (leftPos &gt;= rightPos)
    return;

int center = (leftPos + rightPos) / 2;
mergeSort(list, leftPos, center, tmpList);
mergeSort(list, center + 1, rightPos, tmpList);
merge(list, leftPos, center, rightPos, tmpList);
</code></pre>

<p>}</p>

<p>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,</p>

<pre><code>    Integer[] tmpList) {
int leftIndex  = leftPos;
int rightIndex = leftEnd + 1;
int index = leftIndex;

while (leftIndex &lt;= leftEnd &amp;&amp; rightIndex &lt;= rightEnd) {
    if (list[leftIndex] &lt;= list[rightIndex]) {
        tmpList[index++] = list[leftIndex++];
    } else {
        tmpList[index++] = list[rightIndex++];
    }
}

while (leftIndex &lt;= leftEnd) {
    tmpList[index++] = list[leftIndex++];
}
while (rightIndex &lt;= rightEnd) {
    tmpList[index++] = list[rightIndex++];
}

for (int i = leftPos; i &lt;= rightEnd; i ++) {
    list[i] = tmpList[i];
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java的java.util.Arrays中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java实现</p>

<p>```
public int leftChild(int n) {</p>

<pre><code>return 2*n + 1;
</code></pre>

<p>}</p>

<p>public void percolateDown(int[] list, int n, int length) {</p>

<pre><code>int tmp;
int child;

for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
    child = leftChild(n);

    if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1]) {
        child ++;
    }

    if (tmp &lt; list[child]) {
        list[n] = list[child];
    }else {
        break;
    }
}

list[n] = tmp;
</code></pre>

<p>}</p>

<p>public void sort(int[] list) {</p>

<pre><code>for (int i = list.length/2; i &gt;= 0; i --) {
    percolateDown(list, i, list.length);
}

for (int i = list.length - 1; i &gt; 0; i --) {
    int tmp = list[i];
    list[i] = list[0];
    list[0] = tmp;

    percolateDown(list, 0, i);
}
</code></pre>

<p>}</p>

<p>```</p>

<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共O(n)，需要辅助空间O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个27后，原来在后面的27被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并1中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N个数组的排序，有N!种可能结果，我们需要在N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为1/2和1/2，也就一次比较中a&lt;b的概率和a>b的概率一样，如果能保证一这一点，就能保证最优下界，也就是log2(N!)，这个值近似于NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[邮件服务（三）：实践服务器搭建]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/01/22/email-3/"/>
    <updated>2014-01-22T01:14:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/01/22/email-3</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://biaobiaoqi.github.io/tags/you-jian-fu-wu/">邮件服务系列博文</a>中，前两篇介绍了邮件系统的基本功能和安全体系，本文记录了搭建邮箱服务器的实践。</p>

<p><a href="http://en.wikipedia.org/wiki/Sendmail">Sendmail</a>是一种多用途、支援多种协定的跨网络电子邮件传送代理软件，于1983年随着BSD 4.1c首次发行，2001年时的调查，互联网上的邮件服务器有42%使用Sendmail，但之后由于多次被发现重大的安全性漏洞，且其设定档过于复杂造成较高的学习门槛等因素，导致市占率下滑。</p>

<p><a href="http://www.postfix.org/">Postfix</a>被<a href="http://www.porcupine.org/wietse/">Wietse Zweitze Venema</a>创造出来以取代Sendmail。本次实践即使用Postfix为域名biaobiaoqi.me搭建邮箱服务器，服务器是Linode上的VPS，Ubuntu 12.04LTS，DNS服务器使用<a href="http://dnspod.com/">DNSPod</a>。</p>

<!--more-->


<h2>检查IP信用度</h2>

<p>在自建邮件服务器之前，先检查所要使用的IP的信用度。如果IP已经在垃圾邮件联盟的黑名单里面，意味着这个IP在此之前或许被用作发送垃圾邮件，不愿意给这个IP擦屁股的话，就换个IP好了。</p>

<p>可以点下面的链接查看：</p>

<ul>
<li><a href="http://anti-spam.org.cn/">http://anti-spam.org.cn/</a></li>
<li><a href="http://www.justspam.org/check-an-ip">http://www.justspam.org/check-an-ip</a></li>
<li><a href="http://www.spamhaus.org/query/bl?ip=74.125.129.27">http://www.spamhaus.org/query/bl?ip=74.125.129.27</a> #需要将连接末尾的IP替换为邮箱服务器的IP</li>
</ul>


<h2>域名、IP相关配置</h2>

<h3>FQDN配置</h3>

<p>选定的邮箱服务器需要有合适的全名。比如可以设定biaobiaoqi.me的邮箱服务器的FQDN为mail.biaobiaoqi.me。修改FQDN的命令如下：</p>

<p><code>hostname mail.biaobiaoqi.me</code></p>

<p>查看FQDN的命令为：</p>

<p><code>hostname -f</code></p>

<p>FQDN需要记住，之后配置DNS记录时需要。</p>

<h3>MX记录和A记录</h3>

<p>配置MX记录指向邮箱服务器IP。</p>

<p><code>biaobiaoqi.me.     600 IN  MX  10 biaobiaoqi.me.</code></p>

<p>使用如下命令查询：</p>

<p><code>dig mx biaobiaoqi.me</code></p>

<p>在DNS服务器里增加针对邮箱服务器的FQDN的A记录。</p>

<p><code>mail.biaobiaoqi.me.    10  IN  A   106.186.114.43</code></p>

<p>使用如下命令查询：</p>

<p><code>dig a mail.biaobiaoqi.me</code></p>

<h3>PTR配置</h3>

<p>Linode的域名反向解析设置教程参见：<a href="https://library.linode.com/dns-manager#sph_setting-reverse-dns">Setting Reverse DNS</a></p>

<p>查看PTR的命令如下：</p>

<p><code>dig -x 106.186.114.43</code></p>

<p>得到的结果中有如下项则为正确：</p>

<p><code>
;; ANSWER SECTION:
43.114.186.106.in-addr.arpa. 8640 IN    PTR mail.biaobiaoqi.me.
</code></p>

<h3>SPF配置</h3>

<p>在DNSPod上设置SPF记录。由于DNS本身不支持SPF类型，可以使用TXT记录代替：</p>

<p><code>biaobiaoqi.me.     600 IN  TXT "v=spf1 a mx -all"</code></p>

<p>可以通过如下命令查询：</p>

<p><code>dig txt biaobiaoqi.me</code></p>

<p>在线测试SPF是否部署成功：<a href="http://www.openspf.org/Why?show-form=1">http://www.openspf.org/Why?show-form=1</a></p>

<h2>Postfix搭建</h2>

<p>使用Postfix做SMTP服务器，Dovecot来做IMAP/POP3服务器，并使用Mysql存储加盐密码作认证。具体教程如下：</p>

<p><a href="https://library.linode.com/email/postfix/postfix2.9.6-dovecot2.0.19-mysql"><strong>Email with Postfix, Dovecot, and MySQL</strong></a></p>

<p>启动postfix：</p>

<p><code>sudo service postfix start</code></p>

<p>启动dovecot：</p>

<p><code>sudo dovecot -c /etc/dovecot/dovecot.conf</code></p>

<p>邮件服务启动后，测试相应的端口是否正常开放：</p>

<p>```
netstat -nltp | grep dovecot #查看POP3 （993）和IMAP （995）的端口是否运行</p>

<p>netstat -nltp | grep 25 #查看SMTP（25）的端口是否运行
```</p>

<p>对于没有使用TLS或者STARTTLS的邮件服务器，可以使用<a href="http://exchange.mvps.org/smtp_frames.htm">telnet</a>测试SMTP是否部署成功。而本次实践中增加了用户认证，telnet这种明文传输的协议无法作为测试工具，只好直接使用邮件客户端做功能测试。</p>

<h2>DKIM配置安装</h2>

<p>具体部署过程参照：<a href="https://rtcamp.com/tutorials/mail/dkim-postfix-ubuntu/">dkim-postfix-ubuntu</a></p>

<p>其中需要注意，如果使用的Postfix版本不低于2.6，需要将/etc/postfix/main.cf中的milter_protocol赋值为6。
<code>postconf mail_version</code>可以查看postfix的版本。</p>

<p>本地测试公钥密钥是否正确：（<a href="http://www.opendkim.org/opendkim-testkey.8.html">opendkim-testkey命令的介绍</a>）</p>

<p><code>
-&gt;#opendkim-testkey -d biaobiaoqi.me -s mail -k /etc/postfix/dkim.key -vvv
opendkim-testkey: key loaded from /etc/postfix/dkim.key
opendkim-testkey: checking key 'mail._domainkey.biaobiaoqi.me'
opendkim-testkey: key not secure #这里大概是用户、权限的问题。不会影响基本功能
opendkim-testkey: key OK
</code></p>

<h2>邮箱服务器健康度测试</h2>

<p>完成上述所有步骤后，一个完整的域名邮箱就可以投入使用了。在此之前，可以做一次全面的体检。</p>

<p>推荐使用在线监测服务：<a href="http://www.mail-tester.com/">mail-tester</a>。这是一个全面、界面友好的邮件测试网站。按照要求发送邮件到某邮件地址，然后就可以查到邮件服务器的体检报告了。每项都会有详细的说明。</p>

<h2>遇到的问题记录</h2>

<p>安装部署的过程中，遇到不少问题。简略记录下其中有代表性的一些：</p>

<ul>
<li><p>能成功发送邮件，但无法接受邮件，在日志中查看，全是status=deferred。解决：FQDN的设定错误。</p></li>
<li><p>使用<code>sudo service opendkim start</code>无法启动OpenDKIM。解决：不要使用service命令，而是用如下命令启动：<code>/etc/init.d/opendkim start</code></p></li>
<li><p>在使用Maildir格式接收邮件时，无法接受邮件。解决：需要自己在用户目录下构建Maildir/tmp、Maildir/cur、Maildir/new目录。</p></li>
<li><p>在使用Maildir格式接收邮件时，无法接受邮件。解决：本地Maildir的权限会造成Permission denied。</p></li>
<li><p>给qq邮箱发送邮件，提示『此地址未验证，请注意识别』。解决：这是qq的bug：<a href="http://edm.marketing100.com/service/news_detail.php?ID=126">参见解释</a></p></li>
</ul>


<h2>管理队列中的邮件</h2>

<p>在服务器端管理队列中得邮件使用<code>postqueue</code>和<code>postsuper</code>命令。使用详情参见：</p>

<ul>
<li><a href="http://www.faqforge.com/linux/server/manage-the-postfix-mailqueue-with-postsuper-postqueue-und-mailq/">Manage the postfix mailqueue with postsuper, postqueue und mailq</a></li>
<li><a href="http://www.postfix.org/postqueue.1.html">postqueue</a></li>
<li><a href="http://www.postfix.org/postsuper.1.html">postsuper</a></li>
</ul>


<h2>其他参考资料</h2>

<ul>
<li><a href="https://rtcamp.com/tutorials/mail/">Emails Tutorials</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[邮件服务（二）：安全、认证和垃圾邮件]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/01/21/email-2/"/>
    <updated>2014-01-21T01:38:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/01/21/email-2</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://biaobiaoqi.github.io/tags/you-jian-fu-wu/">邮件服务系列博文</a>中<a href="http://biaobiaoqi.github.io/blog/2014/01/20/email-1/">第一篇博客</a>介绍了邮件服务的基本知识，了解了邮件是如何从发件人的邮件客户端经过不同的传输协议传送到收件人的邮件客户端的。这只是邮件的基本功能实现，但如果发生如下情况，整个邮件系统的生态环境将被扰乱：</p>

<ul>
<li>被不法分子利用邮箱服务器发送垃圾邮件</li>
<li>被其他人伪造域名邮箱发送邮件</li>
<li>被中间人窃取账号密码、甚至重要邮件信息（中间人攻击）</li>
<li>即使自己拥有邮箱服务器的权限，无限制的滥用这个权利给其他邮箱发送邮件也是不好的</li>
</ul>


<p>为了防止以上的种种情况，电子邮箱体系引入了更多的协议和机制。本文对此做浅显的总结，如有出错，还请指出和补充。</p>

<!--more-->


<h2>PTR</h2>

<p><a href="http://en.wikipedia.org/wiki/List_of_DNS_record_types#PTR">PTR</a>(pointer record)是DNS记录中的一种。与A记录相反，它记录的是由IP到<a href="http://en.wikipedia.org/wiki/Fully_qualified_domain_name">FQDN</a>（fully qualified domain name）的映射。</p>

<p>PTR并非由DNS服务提供商控制，而是通过IP提供商来设定。比如博主使用linode的VPS，独立IP 由Linode提供，于是PTR也是由Linode给予的权限来做设定。</p>

<p>在DNS中设置PTR能增加邮件的非垃圾邮件权重（不同垃圾邮件黑名单判定机构有不同的判定规则，其中PTR是公认的指标之一）。</p>

<p>更多信息参考：<a href="https://rtcamp.com/tutorials/mail/fqdn-reverse-dns-ptr-mx-record-checks/">Checking FQDN, Reverse-DNS/PTR, MX record</a></p>

<h2>SPF</h2>

<p><a href="http://en.wikipedia.org/wiki/Sender_Policy_Framework">SPF</a>(Sender Policy Framework)也是一种DNS记录。通过查询发送邮件者的 IP 地址和发送来的邮件地址做对比，进行简单的邮件验证。域名的管理员通过 SPF 记录或 TXT 记录来规定这个域名下哪些 IP 地址是“允许”发送邮件的，这样如果有人用别的 IP 地址来伪造发送的话，收件方可以根据 SPF 来选择拒收这些邮件。</p>

<p>最初的邮件系统没有考虑到各种安全因素，SPF是在之后的发展过程中提出的。为了兼容不支持SPF记录的DNS服务器（本博客所使用的DNSPod就不支持SPF记录。），允许用TXT记录来表达SPF。<a href="www.openspf.org">OpenSPF</a> 建议在这段过渡时期同时添加 SPF 记录和 TXT 记录。</p>

<p>SPF记录的语法规则见<a href="http://www.openspf.org/SPF_Record_Syntax">链接</a>。这里给出一个简单的例子：</p>

<p><code>v=spf1 a mx -all</code></p>

<p>其中<code>spf1</code>是版本号；<code>a</code>代表把A记录对应的IP加入信任列表；<code>mx</code>说明把这个域名上的 MX 记录所对应的服务器加入信任列表；<code>-all</code>代表将不是从信任列表发出的邮件强制拒绝(hard fail)。</p>

<p>值得注意的是，经过测试发现Gmail并没有对hard fail的邮件执行拒绝，只是在web界面做出了一些提醒。这里有一篇相关的讨论：<a href="http://www.gossamer-threads.com/lists/spf/discuss/32914">链接</a>。</p>

<p>更多资料参考：<a href="http://t.tt/31/">如何给域名设置 SPF 记录</a></p>

<h2>DKIM</h2>

<p><a href="http://www.dkim.org/">DKIM</a>(DomainKeys Identified Mail)是一种电子邮件的验证技术，使用<a href="http://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">非对称加密</a>为邮件提供了签名与验证的功能。一般来说，发送方会在电子邮件的标头插入DKIM-Signature及电子签名，它们由私钥加密。而接收方则透过DNS查询得到公开密钥后进行验证。</p>

<p>DKIM是由DomainKeys所改进的协定，大多数的运作方式与DomainKeys相同。在2007年2月时，DKIM被列入互联网工程工作小组（IETF）的标准提案，并于同年5月成为正式标准。</p>

<h2>传输协议</h2>

<p>通过标准的TCP/IP做SMTP传输，没有任何安全保障，信息容易被截获。为了保证数据的安全，可以使用SSL/TLS提供加密链接。对于IMAP和POP3使用SSL加密尚可接受，而SMTP会遇到兼容性问题：POP3和IMAP至于MRA和MUA有关，而使用SMTP协议的MTA会与其他的MTA沟通，除非全世界所有MTA节点同时升级为SSL/TLS加密的通信协议，否则会出现部分邮件无法中继的状况。</p>

<p><a href="http://en.wikipedia.org/wiki/STARTTLS">STARTTLS</a>很好的解决了这一问题。STARTTLS是明文传输协议的扩展，它允许在明文连接的基础上将连接升级为加密连接，而不是使用另外一个加密接口。</p>

<p>一般的，邮箱服务器各协议端口设定如下：</p>

<ul>
<li>IMAP：明文端口143，加密端口993</li>
<li>POP3：明文端口110，加密端口995</li>
<li>SMTP：明文端口 25，SSL加密端口465，STARTTLS加密端口587</li>
</ul>


<p>关于SSL、TLS和STARTTLS的区别，参见<a href="https://www.fastmail.fm/help/technology_ssl_vs_tls_starttls.html">链接</a>。</p>

<h2>查看邮件原始信息</h2>

<p>随着邮件在网络中的中转，邮件头会被加入许多必要信息。理解邮件头能帮助理解邮件服务的整个系统，在遇到垃圾邮件时，也可以助于定位问题所在。</p>

<p>GMAIL的Web端可以查看邮件的详细信息。在邮件内容框里，点击右上角的更多选项，选中Show original，如图：</p>

<p><img src="http://biaobiaoqi.u.qiniudn.com/emailori-mail.png?imageView/2/w/800/h/800" alt="img" /></p>

<p>下面展示linode发送给someuser@gmail.com的一封邮件的原始信息：</p>

<p>```                                                                                                                                                                                                                                                     <br/>
Delivered-To: someuser@gmail.com
Received: by 10.114.246.38 with SMTP id xt6csp139967ldc;</p>

<pre><code>    Mon, 20 Jan 2014 06:53:17 -0800 (PST)
</code></pre>

<p>X-Received: by 10.182.81.197 with SMTP id c5mr7069251oby.40.1390229596297;</p>

<pre><code>    Mon, 20 Jan 2014 06:53:16 -0800 (PST)
</code></pre>

<p>Return-Path: <a href="&#x6d;&#97;&#105;&#x6c;&#x74;&#111;&#58;&#x73;&#x75;&#112;&#112;&#111;&#x72;&#x74;&#64;&#x6c;&#105;&#110;&#111;&#100;&#x65;&#x2e;&#99;&#x6f;&#x6d;">&#115;&#117;&#x70;&#112;&#111;&#x72;&#x74;&#64;&#x6c;&#105;&#x6e;&#111;&#100;&#101;&#x2e;&#99;&#x6f;&#x6d;</a>
Received: from mail2.linode.com (mail2.linode.com. [173.255.198.11])</p>

<pre><code>    by mx.google.com with ESMTP id f6si835374obr.111.2014.01.20.06.53.15
    for &lt;someuser@gmail.com&gt;;
    Mon, 20 Jan 2014 06:53:16 -0800 (PST)
</code></pre>

<p>Received-SPF: pass (google.com: domain of support@linode.com designates 173.255.198.11 as permitted sender) client-ip=173.255.198.11;
Authentication-Results: mx.google.com;</p>

<pre><code>   spf=pass (google.com: domain of support@linode.com designates 173.255.198.11 as permitted sender) smtp.mail=support@linode.com
</code></pre>

<p>Received: from li114-242.members.linode.com (li114-242.members.linode.com [69.164.199.242])</p>

<pre><code>by mail2.linode.com (Postfix) with ESMTP id 6AF9E26A96;
Mon, 20 Jan 2014 09:53:15 -0500 (EST)
</code></pre>

<p>Date: Mon, 20 Jan 2014 09:53:15 -0500 (EST)
From: support@linode.com
To: someuser@gmail.com
Message-ID: <a href="&#109;&#97;&#x69;&#x6c;&#116;&#111;&#58;&#51;&#x37;&#x36;&#55;&#x35;&#48;&#x38;&#x36;&#x38;&#x2e;&#x32;&#54;&#55;&#x36;&#52;&#46;&#49;&#51;&#57;&#x30;&#x32;&#50;&#57;&#53;&#57;&#53;&#52;&#51;&#55;&#46;&#74;&#x61;&#x76;&#x61;&#x4d;&#97;&#x69;&#108;&#46;&#x63;&#x66;&#x75;&#x73;&#x69;&#x6f;&#x6e;&#x40;&#x6d;&#x61;&#x69;&#108;&#50;&#46;&#108;&#x69;&#110;&#111;&#x64;&#101;&#x2e;&#x63;&#111;&#109;">&#51;&#x37;&#x36;&#x37;&#x35;&#48;&#x38;&#54;&#x38;&#46;&#x32;&#x36;&#x37;&#x36;&#52;&#x2e;&#49;&#51;&#x39;&#x30;&#50;&#50;&#57;&#53;&#57;&#x35;&#x34;&#x33;&#55;&#x2e;&#x4a;&#97;&#x76;&#x61;&#x4d;&#97;&#x69;&#108;&#46;&#99;&#x66;&#x75;&#x73;&#105;&#111;&#110;&#x40;&#x6d;&#97;&#x69;&#108;&#50;&#x2e;&#108;&#105;&#x6e;&#x6f;&#x64;&#x65;&#x2e;&#x63;&#111;&#x6d;</a>
```
这封邮件里每项的具体含义如下(<a href="https://support.google.com/mail/answer/29436?hl=en">参考</a>以及<a href="http://www.ietf.org/rfc/rfc0822.txt">RFC0822</a>)：</p>

<ul>
<li>Delivered-TO： 发送的目的地邮箱地址。</li>
<li>Received： 这个字段可以用来追踪邮件的传送路径。字段的基本格式为 from A by B for C。其中A为发送方，B为接收方，C为收件人邮箱地址。由于邮件可能经过多个SMTP服务器中继，故可以有多个Received字段。在邮件头中，以自底向上的顺序阅读它们。对于这封邮件，传送路径为：li114-242.members.linode.com -> mail2.linode.com -> mx.google.com -> 10.182.81.197 -> 10.114.246.38.</li>
<li>Received-SPF： 用于记录SPF查询来验证邮件的安全性，参考<a href="http://www.openspf.org/SPF_Received_Header">SPF Received Header</a></li>
<li>Return-Path： 邮件的回复地址，来自于SMTP中得<code>mail from:</code>命令。</li>
<li>Date： 邮件的发送时间。</li>
<li>From： 客户端显示的发件人地址，可以跟Return-Path中得地址不同。</li>
<li>To： 客户端显示的收件人地址。</li>
</ul>


<p>实际上，Google估计到IP地址为敏感信息，某些情况下会隐藏发送邮件标头中得发件人IP地址（<a href="https://support.google.com/mail/answer/26903?hl=zh-Hans&amp;hlrm=en">资料链接</a>）。</p>

<p>不同的客户端对这一功能做了不同的实现。比如QQ邮箱以前是能够查看邮件原始信息的，而现在已经关闭了这一功能。</p>

<h2>第三方邮件服务</h2>

<p>邮件服务器的基本功能实现虽然看起来简单，但为了让系统拥有足够的稳定性、邮件送达率，还是得付出不小的努力来与复杂的网络环境做斗争。许多公司为了集中注意力于自己的核心业务，会剥离出邮件发送的业务，使用第三方的邮件服务。国内国外涌现了不少第三方的邮件服务解决方案。自己没有相应的使用经验，谨贴出两个不错的介绍，供大家参考：</p>

<ul>
<li><a href="http://70.io/develop/aws_ses-mailgun-sendcloud.html">邮件发送服务AWS SES，Mailgun以及SendCloud</a></li>
<li><a href="http://www.zhihu.com/question/20088568">知乎的邮件系统为什么不再用 Amazon SES 了？</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[邮件服务（一）：基本框架]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/01/20/email-1/"/>
    <updated>2014-01-20T00:11:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/01/20/email-1</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>电子邮件出现在1960s晚期，比打开浏览器就要使用的HTTP协议早了20年左右,是二十世纪人类最伟大的发明之一。这个古老、经典的框架在网络中运行了五十多年，现今仍然是网络中主要的流量类型之一。</p>

<p>不得不提的是，<a href="http://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">wiki</a>上关于中国的第一封电子邮件的记载：1987年9月14日[1]中国第一封电子邮件是由“德国互联网之父”维纳·措恩与王运丰在北京的计算机应用技术研究所发往德国卡尔斯鲁厄大学的，其内容为英文，大意如下：</p>

<blockquote><p>Across the <strong>Great Wall</strong> we can reach every corner in the world.</p></blockquote>

<p>真的是很有远见呢-,-</p>

<p>前几天梳理了电子邮箱相关的协议和框架组件，准备整理成文。一共<a href="http://biaobiaoqi.github.io/tags/you-jian-fu-wu/">三篇</a>，本文是基本知识总结，第二篇介绍安全认证和防垃圾邮件的规范，第三篇记录了邮件服务器的搭建实践。</p>

<!--more-->


<h2>邮件传输所需要的组件</h2>

<p>在解释邮件的传送过程前，先简单介绍一些术语（可以结合）：</p>

<h3>术语</h3>

<h4>Mail Agent</h4>

<p>一般我们将邮件传输中的组件称作Mail Agent，根据功能的不同，它们包括了：</p>

<ul>
<li><strong>MUA</strong>（Mail User Agent）：作为客户端程序，负责从服务器接收邮件，向服务器发送邮件。</li>
<li><strong>MTA</strong>（Mail Transfer Agent）：将邮件发送给目的地址的邮件服务器（目的服务器上也有一个MTA来做接收）。一般提到的Mail Server就是MTA。</li>
<li><strong>MDA</strong>（Mail Delivery Agent）：根据MTA收取的邮件，决定邮件的去向（如果本机就是邮件的目的地址，则放入本地用户邮箱，如果不是，则继续转发）。还可以配置过滤垃圾邮件和自动回复等。</li>
<li><strong>Mailbox</strong>：存储邮件数据。MDA会将邮件放到不同用户的邮箱中。一般的，有mbox、Maildir和dbmail等存储格式。mbox将所有邮件存放到一个文件中，弊端较多。Maildir则将邮件存为单独的文件。</li>
<li><strong>MRA</strong>（Mail Retrieval Agent）：负责与MUA沟通。</li>
</ul>


<h4>协议</h4>

<p>不同Agent之间的数据交通都依赖于协议，这些协议包括：</p>

<ul>
<li><strong>SMTP</strong>（Simple Mail Transfer Protocol）：端口25，面向连接的传输协议。用于MUA向MTA发送邮件，以及MTA之间互相发送和接收邮件。严格来说，MTA其实仅是指SMTP。</li>
<li><strong>POP3</strong>（Post Office Protocol3）：离线协议，MUA从MRA获取邮件使用这一协议。首先验证身份，将邮件传输到MUA后，用户Mailbox中的邮件会被删除。</li>
<li><strong>IMAP</strong>（Internet Message Access Protocol）：与POP3类似，用于从MRA收取邮件。不过MUA与MRA之间双向通信，客户端的改动会反映到服务器上。IMAP 整体上为用户带来更为便捷和可靠的体验，POP3 更易丢失邮件或多次下载相同的邮件，但 IMAP 通过邮件客户端与webmail 之间的双向同步功能很好地避免了这些问题。</li>
</ul>


<h4>其他</h4>

<ul>
<li><p><strong>MX记录</strong>：邮箱服务器DNS的MX记录指向邮箱服务器。MX记录可以设定优先级，数字越小的优先级越高。比如如下两条MX记录：<code>gmail.com.     1656    IN  MX  5 gmail-smtp-in.l.google.com.</code>，<code>gmail.com.        1656    IN  MX  10 alt1.gmail-smtp-in.l.google.com.</code>  <br/>
  MTA会优先选取优先级为5的地址发送，如果不成功，再转向优先级低的服务器发送。而较低优先级的服务器只是用作暂存，将邮件保存在待发送的队列中，等主服务器恢复后中继转发到主服务器，以此容错。</p></li>
<li><p><strong>中继转发</strong>（Relay）：邮件从一台MTA转发到下一台MTA，这个操作就成为邮件中继转发。如果所有人都能使用某台MTA做中继转发，则这台MTA成为Open Relay。这是很危险的，容易被互联网的邮件流量拖垮，且可能被记录到邮箱服务器黑名单上，坏处多多。需要仔细配置Relay规则。</p></li>
</ul>


<h3>邮件传输实例</h3>

<p>从一个简单的应用场景谈起：Biaobiaoqi（简称B）使用自己的邮箱hello@biaobiaoqi.me登陆了自己的foxmail邮件客户端，撰写邮件，发送给shenyapeng(简称S)，S的邮箱地址是shenyapeng@gmail.com。S打开自己的邮件客户端，查收了邮件。</p>

<p>从用户的角度来看，只是简单的将邮件从B发到了S，而实际上邮件在网络中经过了多个协议的传输。其大致流程如下：</p>

<ul>
<li>1.首先邮件需要从B的邮件客户端传送到对应的biaobiaoqi.me邮箱服务器</li>
<li>2.biaobiaoqi.me的邮箱服务器将邮件发送给gmail.com邮箱服务器。</li>
<li>3.S的邮件客户端从gmail邮件服务器获取到信收到的邮件。</li>
</ul>


<p>而更技术的解释如下：</p>

<ul>
<li>1.B登陆PC上得MUA（比如Foxmail、Thunderbird、Outlook等），撰写邮件。MUA使用SMTP将邮件发送给B的邮箱服务器mail.biaobiaoqi.me。</li>
<li>2.mail.biaobiaoqi.me的MDA检测邮件头信息，发现需要将邮件发送给gmail.com邮箱服务器，于是交予MTA来做传输。</li>
<li>3.MTA通过gmail.com的DNS中MX记录，查找到邮箱服务器的IP地址(<code>dig mx gmail.com</code>)，再向目的地中继转发这封邮件。</li>
<li>4.到达目的MTA后，邮件被MDA送到Mailbox中。MRA开始工作，供MUA收取邮件。</li>
<li>5.S登陆MUA，使用POP3或IMAP协议从gmail.com的邮箱服务器MRA收取邮件。</li>
</ul>


<p>无论是邮件客户端跟邮箱服务器之间认证身份，还是邮件数据的传输，都会进行加密。直接暴露在互联网络中是很危险的。安全认证方面的问题会在下一篇讨论，这里先介绍基本的功能协议。要知道最早发明邮件协议时，也并没有将安全问题考虑在内。</p>

<h2>主要参考资料</h2>

<ul>
<li><a href="http://vbird.dic.ksu.edu.tw/linux_server/0380mail.php">鸟哥的Linux私房菜——服务器架设篇</a></li>
<li><a href="http://wiki2.dovecot.org/MailServerOverview">MailServerOverview</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JVM参数调优：Eclipse启动实践]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/01/17/java-performance-tunning-in-practice/"/>
    <updated>2014-01-17T11:16:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/01/17/java-performance-tunning-in-practice</id>
    <content type="html"><![CDATA[<p>本文主要参考自<a href="http://book.douban.com/subject/6522893/">《深入理解Java虚拟机》</a>。这本书是国人写的难得的不是照搬代码注释的且不是废话连篇的技术书，内容涵盖了Java从源码到字节码到执行的整个过程，包括了JVM（Java Virtual Machine）的架构，垃圾收集的介绍等。这里摘录出关于配置JVM基本参数来调优Eclipse启动的过程，比较初级，供初学者参考。</p>

<!--more-->


<h2>基础知识</h2>

<p>针对JVM的参数调优主要集中在数据区大小的控制和垃圾回收策略的选择。关于JVM运行机制等更多内容可参考<a href="http://biaobiaoqi.github.io/tags/jvm/">其他博文</a></p>

<h3>JVM的运行时数据区</h3>

<p>运行时JVM的数据区主要包括各线程私有的栈和程序计数器，线程共享的方法区，以及管理对象的堆（又称回收堆）等。程序运行时，类信息、常量、静态变量等会被加载到方法区。运行过程中几乎所有对象都在堆里，内存占用的空间最大，这也是最值得优化得部分。</p>

<h3>JVM的垃圾回收策略</h3>

<p>Java程序中，除了基本类型（primitive types），其他的数据都是以对象的形式存在。对象生命周期有长有短，如果无区别的保留在内存中，会造成内存超载。内存垃圾回收(Garbage Collection, 缩写GC)就是解决这一问题的策略。</p>

<p><em>注意：JVM不仅仅只对对象进行垃圾回收，实际上也会对废弃常量和无用的类做回收。</em></p>

<p>垃圾回收首先得找到需要被回收的对象，一般采用根搜索算法来标记处这些过时的对象（另外有一种简单的实现：<a href="http://zh.wikipedia.org/wiki/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0">引用计数</a>，但存在明显的弊端，即循环引用）。</p>

<p>回收垃圾的过程会消耗计算资源和时间。根据不同的处理方式，垃圾回收有不同的策略，现在常用的是分代收集算法：根据对象的存活周期将堆划分为几代：新生代（Young Generation或New Generation）和老生代（Tenured Generation），<a href="http://en.wikipedia.org/wiki/HotSpot">HotSpot虚拟机</a>里还分出了永生代（基本等同于方法区）。不同代采用不同的垃圾回收策略。</p>

<h4>HotSpot虚拟机</h4>

<p>HotSpot虚拟机中，Perm代指永生代，Old代指老年代，而新生代使用复制算法，将区域划分为三块：Eden，S0和S1（S是Survivor的缩写）。</p>

<p>IBM研究表明，新生代中的对象98%是朝生夕死的，三者的比例划分是8：1：1。对象先分配到Eden，如果Eden中内存占用量达到一定得比例，触发Minor GC，JVM会将Eden和S0(或S1)中存活的对象复制到S1（或S0），并清空Eden和S0(或S1)。如果同时老年代的内存占用量打达到一定比例，会触发Major GC（也称Full GC）。通常Major GC比Minor GC慢10倍以上。</p>

<h3>编译过程</h3>

<p>Java一直号称“Write once, run anywhere”，这个特性正是由JVM这一虚拟层来支撑的。</p>

<p>Java源代码首先编译为Java字节码，字节码再被JVM加载运行。运行的过程可以是直接针对字节码的解释执行，也可以是经过了<a href="http://zh.wikipedia.org/wiki/%E5%8D%B3%E6%99%82%E7%B7%A8%E8%AD%AF">JIT</a>（Just in time）编译为机器码后的执行。另外，还有<a href="(http://en.wikipedia.org/wiki/AOT_compiler">静态提前编译器</a>(Ahead Of Time，也缩写为AOT)，能将源码直接编译为机器码。</p>

<p><a href="http://en.wikipedia.org/wiki/HotSpot">HotSpot虚拟机</a>的JIT编译器有：Client Complier（简称C1）、Server Complier（简称C2）以及在Java7中堆出的<a href="http://docs.oracle.com/javase/7/docs/technotes/guides/vm/performance-enhancements-7.html">分层编译器</a>。C1编译器做一些快速的优化，C2做一些更耗时的优化但是产生更高效的代码，而分层编译器则结合了两者的优点：快速的启动和逐步的优化（brings client startup speeds to the server VM）。</p>

<h3>性能监控和故障处理工具</h3>

<p>对于系统调优和问题定位，周志明在《深入Java虚拟机》中总结到</p>

<blockquote><p>给一个系统定位问题的时候，知识、经验是关键基础，数据是依据，工具是运用知识处理数据的手段。这里说的数据包括：运行日志、异常堆栈、GC日志、线程快照、堆转储快照等……应当意识到工具永远都是知识技能的一层包装，没有什么工具是“秘密武器”。</p></blockquote>

<p>Java提供了很多工具给开发者来监控和处理运行中的问题。包括命令行工具以及可视化工具</p>

<h4>命令行工具</h4>

<p>比如jps, jstat, jinfo等。举例如下：</p>

<p><code>
jstat -gcutil xxx #xxx是jps查出的LVMID，查看gc相关数据
jstat -gccause xxx#查看gc的原因
jinfo  -flag XXX xxx#XXX是参数名，xxx是VMID，查看虚拟机的参数值
</code></p>

<h4>可视化工具</h4>

<ul>
<li>JConsole：比较老得分析软件，Java自带。Windows下搜jconsole.exe，Mac下启动命令为jconsole</li>
<li><a href="http://www.eclipse.org/mat/">Eclipse Memory Analyzer Tool</a>：用于分析dump下的堆数据</li>
<li><a href="http://visualvm.java.net/">VisualVM</a>:推荐，很全能的分析工具</li>
</ul>


<h3>JVM参数</h3>

<p>这里零散的罗列了一些我用到的简单的JVM配置参数：</p>

<p>内存大小控制：</p>

<ul>
<li>-Xmx20M: 堆的最大值</li>
<li>-Xms10M: 堆的初始分配内存</li>
<li>-Xmn: 新生代堆的分配内存</li>
<li>-Xss128k: 线程的栈空间大小</li>
<li>-XX:PermSize=10M | 方法区初始大小</li>
<li>-XX:MaxPermSize=10M |方法区最大值</li>
</ul>


<p>编译相关：</p>

<ul>
<li>-Xint: 关闭JIT，完全使用解释执行，实践中没什么作用，解释执行很慢。</li>
<li>-client: 启动C1编译器</li>
<li>-server: 启动C2编译器</li>
<li>-XX:+TieredCompilation: 启动分层编译器</li>
</ul>


<p>其他：</p>

<ul>
<li>-XX:+DisableExplicitGC: 屏蔽System.gc()调用</li>
<li>-PrintGCDetails: 让jvm在每次发生gc的时候打印日志，利于分析gc的原因和状况</li>
<li>-XX:+HeapDumpOnOutOfMemoryError: 内存溢出时dump下heap，可以通过Eclipse Memory Analyzer Tool打开查看。</li>
<li>-XX:HeapDumpPath=/: dump下的heap文件快照的路径。Eclipse中默认放到项目的根目录中</li>
<li>-XVerify:none: 禁止字节码验证</li>
</ul>


<h2>调优Eclipse启动的实践</h2>

<h3>实践环境</h3>

<ul>
<li>CPU： 2.8 GHz Intel Core i7</li>
<li>内存： 8 GB 1333 MHz DDR3</li>
<li>操作系统： OS X 10.9.1(64bits)</li>
<li>Eclipse：Version: Kepler Service Release 1， Build id: 20130919-0819</li>
<li>Java：java version "1.7.0_45"</li>
</ul>


<h3>调优实践</h3>

<p>调优Eclipse启动实际上就是调优Eclipse在JVM中的加载和程序启动阶段的运行。由于默认的Ecpise启动配置无法适应所有不同的硬件、软件环境，做针对性的调优是必要的。</p>

<p>Eclipse的启动配置文件是eclipse.ini，对JVM的参数调优直接在该文件中修改。OS X下，其文件路径为 $ECLIPSE/Eclipse.app/Contents/MacOS/eclipse.ini（<em>注意不是Eclipse文件包根目录下得eclipse.ini</em>）。</p>

<h4>测Eclipse启动时间</h4>

<p>要优化Eclipse的启动时间，先要能确定Eclipse的启动时间。这里推荐网友实现的一个Eclipse插件：<a href="http://empirel.iteye.com/blog/1404226">计算启动时间的Eclipse插件</a>。下载后放到Eclipse的插件包中，启动Eclipse即可看到弹窗显示的启动时间。为了得到一个尽可能公平的测试结果，需要在测试过程中关闭其他程序，避免CPU负载带来的误差，并多次测试取平均值。</p>

<h4>调优策略</h4>

<p>使用VisualVM查看程序的运行状况来定位瓶颈，尝试调优解决。下图是VisualVM的示例图，右边图示展示了GC的状态以及编译时间、类加载时间和垃圾回收时间等指标。</p>

<p><img src="http://biaobiaoqi.u.qiniudn.com/visualvmscreen.png?imageView/2/w/800/h/800" alt="img" /></p>

<p>也可以通过命令行工具查看GC的状态，比如：<code>jstat -gc XXX #其中XXX是jps查出的进程的LVMID</code>.</p>

<p>我的实践总结如下：</p>

<ul>
<li>类加载时间过长：禁止加载类时的字节码验证。我们认为Eclipse的字节码是可靠的。<code>-XVerify:none</code></li>
<li>编译时间：<code>-client</code>缩短了编译时间，但长期运行的性能可能受影响，<code>-server</code>编译时间长，而编译优化做得更多，后期使用汇报大，<code>-XX:+TieredCompilation</code>分层编译则集合了前两者的优势。没有特殊需求，可选用这一编译选项。</li>
<li>Minor GC次数太多：新生代空间太小，加大新生代的内存大小。<code>-Xmn800m</code>，同时，增大回收堆的总大小上限（<code>-Xmx1024m</code>）。</li>
<li>Full GC次数太多：为了避免回收堆由小到大的动态增长增加时间开销，可将其初始大小跟最大上限设定为同一值<code>-Xms1024m</code>，并增加老年代的大小(<code>-XX:PermSize=256m</code>，<code>-XX:MaxPermSize=256m</code>)。</li>
<li>代码中的GC调用：Eclipse代码中有System.GC()的调用可能促使JVM执行垃圾回收，可以通过<code>-XX:+DisableExplicitGC</code>来防止。</li>
<li>垃圾收集器的选择：垃圾收集器有很多，比如Serial、ParNew、Parallel Scavenge、CMS、G1等。推荐使用老生代CMS新生代ParNew的组合来应对Eclipse用户交互频繁的情况(<code>-XX:+UseParNewGC</code>、<code>-XX:+UserConcMarkSweepGC</code>)。同时提升CMS的垃圾回收的触发条件：<code>-XX:CMSInitiatingOccupancyFraction=85</code>，进一步降低Full GC的出现。</li>
</ul>


<h4>最终eclipse.ini</h4>

<p><code>
-startup
../../../plugins/org.eclipse.equinox.launcher_1.3.0.v20130327-1440.jar
--launcher.library
../../../plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.1.200.v20130807-1835
-product
org.eclipse.epp.package.standard.product
--launcher.defaultAction
openFile
-showsplash
org.eclipse.platform
--launcher.XXMaxPermSize
256m
--launcher.defaultAction
openFile
--launcher.appendVmargs
-vmargs
-Dosgi.requiredJavaVersion=1.6
-XstartOnFirstThread
-Dorg.eclipse.swt.internal.carbon.smallFonts
-Xms1024m
-Xmx1024m
-Xmn800m
-Xdock:icon=../Resources/Eclipse.icns
-XstartOnFirstThread
-Dorg.eclipse.swt.internal.carbon.smallFonts
-XX:+TieredCompilation
-XX:PermSize=256m
-XX:MaxPermSize=256m
-XX:+DisableExplicitGC
-XVerify:none
-XX:+UseParNewGC
-XX:+UserConcMarkSweepGC
-XX:CMSInitiatingOccupancyFraction=85
</code></p>

<h2>其他参考</h2>

<ul>
<li><a href="http://www.searchtb.com/2013/07/jvm-gc-introduction-examples.html">《JVM的GC简介和实例》</a> — 搜索技术博客－淘宝.昆仑</li>
</ul>

]]></content>
  </entry>
  
</feed>
