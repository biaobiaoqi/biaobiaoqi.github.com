
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Biaobiaoqi的博客</title>
  <meta name="author" content="Biaobiaoqi">

  
  <meta name="description" content="更新至 1068 2013-10-08
更新至 1072 2013-11-07 PAT(pat.zju.edu.cn)是一个面向 C/C++程序的 Online Judge 系统。相比 ZOJ，HDOJ，POJ 等 ACM 题库，PAT 的题目非常基础，对于数据结构、算法的入门是比较有助益的。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://biaobiaoqi.github.io/blog/page/14/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Biaobiaoqi的博客" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<script type="text/javascript">

function addBlankTargetForLinks () {

  $('a[href^="http"]').each(function(){

      $(this).attr('target', '_blank');

  });

}

$(document).bind('DOMNodeInserted', function(event) {

  addBlankTargetForLinks();

});

</script>


<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F49481ec3305db999013860b0ccb3b16d' type='text/javascript'%3E%3C/script%3E"));
</script>


  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-39900036-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Biaobiaoqi的博客</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:biaobiaoqi.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">首页</a></li>
  <li><a href="/blog/archives/">全部文章</a></li>
  <li><a href="/tag-cloud/">分类阅读</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/03/overcome-pat/">PAT练习题概览</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-03T22:20:00+08:00" pubdate data-updated="true">Aug 3<span>rd</span>, 2013</time>
        
         | <a href="/blog/2013/08/03/overcome-pat/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>更新至 1068 2013-10-08</li>
<li>更新至 1072 2013-11-07</li>
</ul>


<p>PAT(<a href="http://pat.zju.edu.cn">pat.zju.edu.cn</a>)是一个面向 C/C++程序的 Online Judge 系统。相比 ZOJ，HDOJ，POJ 等 ACM 题库，PAT 的题目非常基础，对于数据结构、算法的入门是比较有助益的。</p>

<p>本文按照自己的认识，给 PAT advanced level 做出了分类。由于很多题目实际上兼顾有多种解法和思路，我给每道题打上了 tag，来应对分类的独占性局限，供大家参考。</p>

<h2>简单题</h2>

<p>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>

<ul>
<li>1001 A+B</li>
<li>1002 多项式相加</li>
<li>1005 简单 hash</li>
<li>1006 选极值</li>
<li>1008 模拟电梯</li>
<li>1009 多项式乘法</li>
<li>1011 选极值</li>
<li>1019 数字/字符处理</li>
<li>1024 数字/字符处理</li>
<li>1027 数字/字符处理，简单 hash</li>
<li>1031 数字/字符处理</li>
<li>1035 简单 hash</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/03/overcome-pat/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/03/overcome-pat/">PAT练习题概览</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-03T22:20:00+08:00" pubdate data-updated="true">Aug 3<span>rd</span>, 2013</time>
        
         | <a href="/blog/2013/08/03/overcome-pat/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li>更新至 1068 2013-10-08</li>
<li>更新至 1072 2013-11-07</li>
</ul>


<p>PAT(<a href="http://pat.zju.edu.cn">pat.zju.edu.cn</a>)是一个面向 C/C++程序的 Online Judge 系统。相比 ZOJ，HDOJ，POJ 等 ACM 题库，PAT 的题目非常基础，对于数据结构、算法的入门是比较有助益的。</p>

<p>本文按照自己的认识，给 PAT advanced level 做出了分类。由于很多题目实际上兼顾有多种解法和思路，我给每道题打上了 tag，来应对分类的独占性局限，供大家参考。</p>

<h2>简单题</h2>

<p>这类题几乎不需要数据结构、算法基础，主要通过简单的逻辑流程和判断实现。</p>

<ul>
<li>1001 A+B</li>
<li>1002 多项式相加</li>
<li>1005 简单 hash</li>
<li>1006 选极值</li>
<li>1008 模拟电梯</li>
<li>1009 多项式乘法</li>
<li>1011 选极值</li>
<li>1019 数字/字符处理</li>
<li>1024 数字/字符处理</li>
<li>1027 数字/字符处理，简单 hash</li>
<li>1031 数字/字符处理</li>
<li>1035 简单 hash</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/03/overcome-pat/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1051-1060-solutions/">PAT 1051-1060 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1051-1060-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">1051. Pop Sequence (25)</a></h2>

<h4>题意</h4>

<p>给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li>{1 2 3 4 5 6 7}： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li>{3 2 1 7 5 6 4}： 这个序列是不可能的，其中前半部分 3 2 1 是合法的，先将 1 2 3 顺序入栈，然后三次执行出栈操作。而之后的 7 5 6 则是不可能的。</li>
</ul>


<h4>分析</h4>

<p>两种思路：</p>

<h5>第 1 种思路：</h5>

<p>使用 stl 中的 stack 模拟。判定条件有两条：1.栈中数据量不超过栈的容量；2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<h5>第 2 种思路：</h5>

<p>由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。
对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，
  那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。
  距离如 3 2 1 7 5 6 4 这个序列，在 7 之后有 5 6 4 这个子序列，它们都大于 7，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>更多分析参见博文<a href="../../../../2013/07/16/verify-pop-sequence-for-stack/">《出栈序列的可能性判定》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1052">1052. Linked List Sorting (25)</a></h2>

<h4>题意</h4>

<p>链表的节点被表示为{地址， 值， 下一个指针地址}，其中如果 NULL 的地址表示为-1，
地址为 5 正数，值的范围为[-10<sup>5,</sup> 10<sup>5]。</sup></p>

<p>给定 N(&lt; 10<sup>5)个节点以及其头指针，要求按照每个节点上值的大小重新排序，并按照链表顺序输出每个节点。</sup></p>

<h4>分析</h4>

<p>将链表中的节点按值做 qsort()排序，然后调整每个值的 next 指针即可。需要注意的有：</p>

<ul>
<li>1.INPUT 中的节点并不保证全是链表中的，先需要过滤掉悬空的节点。</li>
<li>2.head 直接指向-1(NULL)的情况需要特殊处理。</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1051-1060-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1051-1060-solutions/">PAT 1051-1060 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1051-1060-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">1051. Pop Sequence (25)</a></h2>

<h4>题意</h4>

<p>给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li>{1 2 3 4 5 6 7}： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li>{3 2 1 7 5 6 4}： 这个序列是不可能的，其中前半部分 3 2 1 是合法的，先将 1 2 3 顺序入栈，然后三次执行出栈操作。而之后的 7 5 6 则是不可能的。</li>
</ul>


<h4>分析</h4>

<p>两种思路：</p>

<h5>第 1 种思路：</h5>

<p>使用 stl 中的 stack 模拟。判定条件有两条：1.栈中数据量不超过栈的容量；2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<h5>第 2 种思路：</h5>

<p>由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。
对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，
  那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。
  距离如 3 2 1 7 5 6 4 这个序列，在 7 之后有 5 6 4 这个子序列，它们都大于 7，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>更多分析参见博文<a href="../../../../2013/07/16/verify-pop-sequence-for-stack/">《出栈序列的可能性判定》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1052">1052. Linked List Sorting (25)</a></h2>

<h4>题意</h4>

<p>链表的节点被表示为{地址， 值， 下一个指针地址}，其中如果 NULL 的地址表示为-1，
地址为 5 正数，值的范围为[-10<sup>5,</sup> 10<sup>5]。</sup></p>

<p>给定 N(&lt; 10<sup>5)个节点以及其头指针，要求按照每个节点上值的大小重新排序，并按照链表顺序输出每个节点。</sup></p>

<h4>分析</h4>

<p>将链表中的节点按值做 qsort()排序，然后调整每个值的 next 指针即可。需要注意的有：</p>

<ul>
<li>1.INPUT 中的节点并不保证全是链表中的，先需要过滤掉悬空的节点。</li>
<li>2.head 直接指向-1(NULL)的情况需要特殊处理。</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1051-1060-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1051-1060-solutions/">PAT 1051-1060 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1051-1060-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1051">1051. Pop Sequence (25)</a></h2>

<h4>题意</h4>

<p>给定 stack 的容量，给定数据的入栈顺序：从 1 开始的正整数序列，在允许随机的出栈操作的情况下，要求判断某出栈序列是否可能。</p>

<p>比如，告知 stack 容量为 5，入栈序列的最大值为 7。有两个序列需要判断合理性：</p>

<ul>
<li>{1 2 3 4 5 6 7}： 这个序列是可能的，只需每次入栈时都做出栈操作。</li>
<li>{3 2 1 7 5 6 4}： 这个序列是不可能的，其中前半部分 3 2 1 是合法的，先将 1 2 3 顺序入栈，然后三次执行出栈操作。而之后的 7 5 6 则是不可能的。</li>
</ul>


<h4>分析</h4>

<p>两种思路：</p>

<h5>第 1 种思路：</h5>

<p>使用 stl 中的 stack 模拟。判定条件有两条：1.栈中数据量不超过栈的容量；2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<h5>第 2 种思路：</h5>

<p>由于入栈序列数据由小到大排列非常特殊，要通过出栈序列判定可能性是存在简便思路的。
对比分析题中 Sample 给出的序列，结合上面提到的两条冲突条件入手分析：</p>

<ul>
<li><p>1.栈中数据量不超过栈的容量：</p>

<p>  只有在入栈时，才会需要考虑栈中数据是否超量。出栈序列中的每个数，都以为着在出栈操作之前，它刚入栈，
  那么当它入栈的时候能否判定是否超过栈容量呢？可以的，（当前的出栈数值 - 已经执行过的出栈操作数量）就是当前栈中元素的数量。</p></li>
<li><p>2.出栈只能从栈顶取，不应该出现从固定的堆栈中取出其他数据的情况。</p>

<p>  根据观察分析发现，当某数据 m 出栈之后，比 m 小的数据如果在 m 之后出栈的，它们所组成的序列本身需要保持从大到小的顺序排列。
  距离如 3 2 1 7 5 6 4 这个序列，在 7 之后有 5 6 4 这个子序列，它们都大于 7，但却没有保持一个递减的顺序，不合法。</p></li>
</ul>


<p>更多分析参见博文<a href="../../../../2013/07/16/verify-pop-sequence-for-stack/">《出栈序列的可能性判定》</a></p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1052">1052. Linked List Sorting (25)</a></h2>

<h4>题意</h4>

<p>链表的节点被表示为{地址， 值， 下一个指针地址}，其中如果 NULL 的地址表示为-1，
地址为 5 正数，值的范围为[-10<sup>5,</sup> 10<sup>5]。</sup></p>

<p>给定 N(&lt; 10<sup>5)个节点以及其头指针，要求按照每个节点上值的大小重新排序，并按照链表顺序输出每个节点。</sup></p>

<h4>分析</h4>

<p>将链表中的节点按值做 qsort()排序，然后调整每个值的 next 指针即可。需要注意的有：</p>

<ul>
<li>1.INPUT 中的节点并不保证全是链表中的，先需要过滤掉悬空的节点。</li>
<li>2.head 直接指向-1(NULL)的情况需要特殊处理。</li>
</ul>


</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1051-1060-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1041-1050-solutions/">PAT 1041-1050 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1041-1050-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1041">1041. Be Unique (20)</a></h2>

<h5>题意</h5>

<p>给出 N (&lt;=105)个数（数值范围为 [1, 10<sup>4]），找到其中不重复的第一个数字。比如给出</sup> <code>5 31 5 88 67 88 17</code> ， 答案是 <code>31</code> 。</p>

<h5>分析</h5>

<p>简单模拟题，开一个大数组<code>int a[10001];</code>，以读入的数为下标，记录 count:<code>a[index] ++;</code>。结果输出第一个存储为 1 的下标:<code>if (a[index] == 1)</code>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1042">1042. Shuffling Machine (20)</a></h2>

<h5>题意</h5>

<p>背景是洗牌机的洗牌过程。过程是给定洗牌的每张牌的位置替换序列，由原来的次序算出最后的牌的平排列。</p>

<p>比如原有的次序为<code>S3, H5, C1, D13, J2</code>，
给定的洗牌顺序为<code>4, 2, 5 ,3 ,1</code>，那么一次洗牌的结果为：<code>J2, H5, D13, S3, C1</code>。
如果需要两次洗牌，则结果为<code>C1, H5, S3, J2, D13</code>。</p>

<p>输入为对一整副牌（54 张）的洗牌策略，以及洗牌次数 N，要求计算出最后的洗牌结果。</p>

<h5>分析</h5>

<p>简单 hash 题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1041-1050-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1041-1050-solutions/">PAT 1041-1050 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1041-1050-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1041">1041. Be Unique (20)</a></h2>

<h5>题意</h5>

<p>给出 N (&lt;=105)个数（数值范围为 [1, 10<sup>4]），找到其中不重复的第一个数字。比如给出</sup> <code>5 31 5 88 67 88 17</code> ， 答案是 <code>31</code> 。</p>

<h5>分析</h5>

<p>简单模拟题，开一个大数组<code>int a[10001];</code>，以读入的数为下标，记录 count:<code>a[index] ++;</code>。结果输出第一个存储为 1 的下标:<code>if (a[index] == 1)</code>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1042">1042. Shuffling Machine (20)</a></h2>

<h5>题意</h5>

<p>背景是洗牌机的洗牌过程。过程是给定洗牌的每张牌的位置替换序列，由原来的次序算出最后的牌的平排列。</p>

<p>比如原有的次序为<code>S3, H5, C1, D13, J2</code>，
给定的洗牌顺序为<code>4, 2, 5 ,3 ,1</code>，那么一次洗牌的结果为：<code>J2, H5, D13, S3, C1</code>。
如果需要两次洗牌，则结果为<code>C1, H5, S3, J2, D13</code>。</p>

<p>输入为对一整副牌（54 张）的洗牌策略，以及洗牌次数 N，要求计算出最后的洗牌结果。</p>

<h5>分析</h5>

<p>简单 hash 题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1041-1050-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1041-1050-solutions/">PAT 1041-1050 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1041-1050-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1041">1041. Be Unique (20)</a></h2>

<h5>题意</h5>

<p>给出 N (&lt;=105)个数（数值范围为 [1, 10<sup>4]），找到其中不重复的第一个数字。比如给出</sup> <code>5 31 5 88 67 88 17</code> ， 答案是 <code>31</code> 。</p>

<h5>分析</h5>

<p>简单模拟题，开一个大数组<code>int a[10001];</code>，以读入的数为下标，记录 count:<code>a[index] ++;</code>。结果输出第一个存储为 1 的下标:<code>if (a[index] == 1)</code>。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1042">1042. Shuffling Machine (20)</a></h2>

<h5>题意</h5>

<p>背景是洗牌机的洗牌过程。过程是给定洗牌的每张牌的位置替换序列，由原来的次序算出最后的牌的平排列。</p>

<p>比如原有的次序为<code>S3, H5, C1, D13, J2</code>，
给定的洗牌顺序为<code>4, 2, 5 ,3 ,1</code>，那么一次洗牌的结果为：<code>J2, H5, D13, S3, C1</code>。
如果需要两次洗牌，则结果为<code>C1, H5, S3, J2, D13</code>。</p>

<p>输入为对一整副牌（54 张）的洗牌策略，以及洗牌次数 N，要求计算出最后的洗牌结果。</p>

<h5>分析</h5>

<p>简单 hash 题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1041-1050-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1031-1040-solutions/">PAT 1031-1040 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1031-1040-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1031">1031. Hello World for U (20)</a></h2>

<h5>题意</h5>

<p>将给定的字符串打印出 U 型。</p>

<p>比如给定<code>helloworld</code>，打印出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>h  d
</span><span class='line'>e  l
</span><span class='line'>l  r
</span><span class='line'>lowo
</span></code></pre></td></tr></table></div></figure>


<p>设定左边的字符个数为 n1,底边字符个数为 n2,右边字符个数为 n3。需要满足 n1 = n3 = max
{k|k &lt;= n2 for all 3 &lt;= n2 &lt;= N} with n1 + n2 + n3 -3 = N.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1032">1032. Sharing (25)</a></h2>

<h5>题意</h5>

<p>为了节省存储空间，单词使用链表实现。比如对于<code>loading</code>和<code>being</code>两个单词，有如下存储结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>word1 : -&gt; [l] -&gt; [o] -&gt; [a] -&gt; [d]  
</span><span class='line'>                                  \
</span><span class='line'>                                    [i] -&gt; [n] -&gt; [g] -&gt; null
</span><span class='line'>                                  /
</span><span class='line'>word2 : -&gt; [b] -&gt; [e] -------------
</span></code></pre></td></tr></table></div></figure>


<p>输入中，指定了两个单词的首字符的地址，并给出了 N (&lt;= 10<sup>5)个节点，每个节点包含：物理地址（5</sup> 位的正整数），实际存储的字符以及指向的下一个节点的地址。NULL 的地址是-1.
要求找到两单词的的公共后缀开始的地址，如果没有，则输出-1.</p>

<h5>分析</h5>

<p>既然是单词，它的长度应该是有限的，也就是链表不会出现环这种情况（实际上这里的处理方式对于有环无环都适用）。对第一个单词链表做遍历，对爬过的节点做好标记。第二个单词链表也同样做标记，一旦遇到已经标记过的节点，则该节点就是结果。</p>

<p>需要注意一点：直接使用 map 做节点的存储最后一个 case 会超时。而鉴于 5 位正整数的数据量，可以直接使用数组，用空间换时间。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1031-1040-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/08/01/pat-1031-1040-solutions/">PAT 1031-1040 题解</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-08-01T01:43:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/08/01/pat-1031-1040-solutions/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>早期部分代码用 Java 实现。由于 PAT 虽然支持各种语言，但只有 C/C++标程来限定时间，许多题目用 Java 读入数据就已经超时，后来转投 C/C++。浏览全部代码：<a href="https://github.com/biaobiaoqi/CPractice/tree/master/PAT/advancedlevel">请戳</a></p>

<p>本文谨代表个人思路，欢迎讨论;)</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1031">1031. Hello World for U (20)</a></h2>

<h5>题意</h5>

<p>将给定的字符串打印出 U 型。</p>

<p>比如给定<code>helloworld</code>，打印出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>h  d
</span><span class='line'>e  l
</span><span class='line'>l  r
</span><span class='line'>lowo
</span></code></pre></td></tr></table></div></figure>


<p>设定左边的字符个数为 n1,底边字符个数为 n2,右边字符个数为 n3。需要满足 n1 = n3 = max
{k|k &lt;= n2 for all 3 &lt;= n2 &lt;= N} with n1 + n2 + n3 -3 = N.</p>

<h5>分析</h5>

<p>简单模拟题。</p>

<h2><a href="http://pat.zju.edu.cn/contests/pat-a-practise/1032">1032. Sharing (25)</a></h2>

<h5>题意</h5>

<p>为了节省存储空间，单词使用链表实现。比如对于<code>loading</code>和<code>being</code>两个单词，有如下存储结构：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>word1 : -&gt; [l] -&gt; [o] -&gt; [a] -&gt; [d]  
</span><span class='line'>                                  \
</span><span class='line'>                                    [i] -&gt; [n] -&gt; [g] -&gt; null
</span><span class='line'>                                  /
</span><span class='line'>word2 : -&gt; [b] -&gt; [e] -------------
</span></code></pre></td></tr></table></div></figure>


<p>输入中，指定了两个单词的首字符的地址，并给出了 N (&lt;= 10<sup>5)个节点，每个节点包含：物理地址（5</sup> 位的正整数），实际存储的字符以及指向的下一个节点的地址。NULL 的地址是-1.
要求找到两单词的的公共后缀开始的地址，如果没有，则输出-1.</p>

<h5>分析</h5>

<p>既然是单词，它的长度应该是有限的，也就是链表不会出现环这种情况（实际上这里的处理方式对于有环无环都适用）。对第一个单词链表做遍历，对爬过的节点做好标记。第二个单词链表也同样做标记，一旦遇到已经标记过的节点，则该节点就是结果。</p>

<p>需要注意一点：直接使用 map 做节点的存储最后一个 case 会超时。而鉴于 5 位正整数的数据量，可以直接使用数组，用空间换时间。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/08/01/pat-1031-1040-solutions/">Read on &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/15/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/blog/page/13/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>标签云</h1>
 <br /> 
  <ul class="tag-cloud">
    <a style="font-size: 143%" href="/tags/jvm/">JVM</a> &nbsp 
<a style="font-size: 147%" href="/tags/java/">Java</a> &nbsp 
<a style="font-size: 145%" href="/tags/pat/">PAT</a> &nbsp 
<a style="font-size: 109%" href="/tags/octopress/">octopress</a> &nbsp 
<a style="font-size: 115%" href="/tags/fen-bu-shi/">分布式</a> &nbsp 
<a style="font-size: 137%" href="/tags/zi-jie-ma/">字节码</a> &nbsp 
<a style="font-size: 137%" href="/tags/si-kao/">思考</a> &nbsp 
<a style="font-size: 180%" href="/tags/ji-zhu/">技术</a> &nbsp 
<a style="font-size: 128%" href="/tags/fang-fa-lun/">方法论</a> &nbsp 
<a style="font-size: 109%" href="/tags/fu-wu-qi/">服务器</a> &nbsp 
<a style="font-size: 139%" href="/tags/sheng-huo/">生活</a> &nbsp 
<a style="font-size: 153%" href="/tags/suan-fa/">算法</a> &nbsp 
<a style="font-size: 109%" href="/tags/wang-luo/">网络</a> &nbsp 
<a style="font-size: 139%" href="/tags/du-shu/">读书</a> &nbsp 
<a style="font-size: 109%" href="/tags/you-jian-fu-wu/">邮件服务</a>

  </ul>
</section>
<section>
  <h1>关于</h1>
   <p>biaobiaoqi是我的网络id。<br><br>
   我的博客日志：<a href="http://biaobiaoqi.github.io/blog/2013/09/01/blog-log/">请戳</a><br><br>
	</p>
</section>




  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Biaobiaoqi -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  - <span class="credit">Theme by <a href="http://www.gehaxelt.in">Gehaxelt</a></span>
  <span class="credit">and <a href="http://www.it-solutions-neef.de">IT Solutions Neef</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'biaobiaoqisblog';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
