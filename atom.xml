<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Biaobiaoqi的博客]]></title>
  <link href="http://biaobiaoqi.github.io/atom.xml" rel="self"/>
  <link href="http://biaobiaoqi.github.io/"/>
  <updated>2016-04-19T00:27:46+08:00</updated>
  <id>http://biaobiaoqi.github.io/</id>
  <author>
    <name><![CDATA[Biaobiaoqi]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[重新启程]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2016/04/18/new-start/"/>
    <updated>2016-04-18T12:49:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2016/04/18/new-start</id>
    <content type="html"><![CDATA[<p>that&#8217;s it！</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2016/04/18/new-start/'>http://biaobiaoqi.github.io/blog/2016/04/18/new-start/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新启程]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2016/04/18/new-start/"/>
    <updated>2016-04-18T12:49:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2016/04/18/new-start</id>
    <content type="html"><![CDATA[<p>that&#8217;s it！</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2016/04/18/new-start/'>http://biaobiaoqi.github.io/blog/2016/04/18/new-start/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重新启程]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2016/04/18/new-start/"/>
    <updated>2016-04-18T12:49:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2016/04/18/new-start</id>
    <content type="html"><![CDATA[<p>that&#8217;s it！</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2016/04/18/new-start/'>http://biaobiaoqi.github.io/blog/2016/04/18/new-start/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近几天]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/"/>
    <updated>2014-05-23T23:25:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/23/recent-days</id>
    <content type="html"><![CDATA[<p>再不写几篇技术博客，本站就彻底沦为个人心情垃圾桶了……在此之前，还是写写这些日子的生活吧 LOL.</p>

<h2>病痛</h2>

<p>这个伤心<del>（让人开心）</del>的故事是这样开始的。4 月底，忍耐了快两年的<code>蛀牙</code>，终于慢慢的被蛀空了，吃东西、喝凉水都疼，迫不得已去看医生。</p>

<p>看牙医的前一天晚上，发现全身起包，瘙痒难当。梦里醒来，模模糊糊的以为是饥渴的蚊子咬的，起床给全身抹了一遍六神，强忍着继续睡了。第二天，包不仅没消，还有疯长的趋势。在牙医的提点下，我又去挂了一个皮肤科，医生很淡然的告诉我这叫<code>过敏</code>。于是，在治疗蛀牙的同时，我又收获了几包抗过敏的药。</p>

<p>医生同时也告诉我，我的蛀牙已经烂到了神经，必须剔除全部神经，大概需要四五个疗程，隔周治疗一次。于是他开始打麻药钻神经了。我对麻药的药效很不敏感，总之我是能感受到那股钻心的疼痛的，咬咬牙忍了。</p>

<!--more-->


<p>过了两周，蛀牙的处理进行到后期了，拍牙片准备做牙套。拍片的时候又传来噩耗：<code>智齿横长阻生</code>，医生的建议是：为了避免它影响旁侧待补的蛀牙，拔掉它。于是，我又开起了拔智齿的线程。这颗智齿聪明的把自己埋在肉里，手术过程是：切开肉，敲碎半颗牙，拔出，缝上……手术过程在充分的麻醉下进行，并不疼。只是医生拿着锤子、凿子各路兵器敲敲打打的时候，脑子里感觉还是一阵阵轰鸣眩晕。疼的还属麻药消去的时间，只能吃流食，不能吃太热，不能吐口水……</p>

<p>还没有结束呢。前天下午觉得头痛不舒服，<code>感冒</code>了。我读书少，是个粗人，纯粹的觉得感冒这种小病，运动下就痊愈了吧，于是晚上一个人拿着篮球去投篮玩。久违的自己一个人练练球，可开心了。捡球的时候，<code>崴了脚</code>……去校医院包扎，正好开了感冒药。</p>

<p>下图就是积攒的各种各样的药片啦。</p>

<p><img src="http://biaobiaoqi.u.qiniudn.com/2014-05-22%2021.49.04.jpg?imageView/2/w/800/h/800" alt="药" /></p>

<h2>心疾</h2>

<p>身体的病，能治的去医院就好，不能治的暂时没碰到。倒是心理的焦躁很难察觉，当它肆意的蔓延开来时，已经留下了一个接一个烂坑等着你爬。这不才是现代人疏于应付的疾病么？最近的我就是一个很好的例子。</p>

<p><del>简单的讲，有时候觉得除了实验室的活儿，其他的事情我都还蛮感兴趣的。</del></p>

<p>客观的原因不提也罢，谁没几个不顺心，让不顺心搞得焦头烂额就是自己的责任了。主观原因则可以归结到自己的人生观、世界观、价值观，太大了也不方便展开。还是想想怎么解决吧。</p>

<p>对于有些人，<code>早起</code>情况能反应精神状态。我原以为我也是这样，于是经常企图用第二天早起来提升士气。后来才发现，我的精神状态指标其实不是早起，而是<code>晚睡</code>。</p>

<p>比如做<a href="http://chahaoyou.com/">查好友</a> iOS 第一版的时候，每天夜里可以编码到凌晨 4、5 点。比如当我决定补充下算法基础时，写 <a href="http://pat.zju.edu.cn/">PAT</a> 和 <a href="https://oj.leetcode.com/problems/">leetcode</a> 也可以通宵。还有一些通宵，是在查自己感兴趣的资料，写有意思的文字和代码。</p>

<p>我对睡眠的驾驭应该远低于平均水平，年少轻狂的一度以此为荣。直到觉得身体有些力不从心。身体是革命的本钱，当身体告诉我不可以，那就绝无可能把晚睡本身作为健康精神状态的指标。其实，这些晚睡无非是那些感兴趣到让我无法自拔的事情在怂恿。</p>

<p>白天在公共场合，各方面因素推着人走，只有晚上独处时，才寻得那点自由。换句话讲，如果一定要说哪些事实能标志自己的精神状态，那就是晚上睡前在做什么了。说白了，也就是自己是不是在做着自己想做的事情。</p>

<p>不过，还是那句话，谁没几个不顺心。让不顺心流淌到全身的血液，那就是幼稚了。</p>

<h2>禁欲</h2>

<p>首先，不要想歪。</p>

<p>大二的某一天，突然想削减上人人的时间，将他们拿来做点更有意思的事情。几经注销、重新登入，成功的让自己养成了在悠闲地不知道做啥时也没了上人人的欲望。</p>

<p>这次，主角变成了<del>新浪</del>微薄。当我意识到一旦思维主动或被动的空闲下来，我就会不假思索的通过<code>cmd+tab(选中 chrome) -&gt; cmd + t (打开新标签) -&gt; 输入 w(自动补全为 weibo.com) -&gt; enter</code>打开微薄页面时，我觉得是时候跟她说再见了。</p>

<p>禁言的头几天，作为思维停顿时的习惯性反射，打开微博的组合动作仍然时有发生。渐渐的就没了兴趣。除了黄海波被抓的时候看看最新的情况，隔三差五处理下艾特自己的内容，微薄淡出了自己的视野。</p>

<p>微薄禁言，似乎是个好的转变。不过触发自己转变的，想必也是比较糟糕的状态了。比如连连宵夜，比如晚上早早的跑回寝室玩耍，比如饭后闲逛网页根本停不下来……而且，也没见自己的士气有多好的提升。</p>

<p>说到底，禁欲不是为了禁谁，而是为了更好的做其他事情。没有后者，前者也只是短效的麻痹而已。</p>

<h2>做和坚持</h2>

<p>最近一段时间，终于完成了一个思维习惯的转变：以前总是事先安排、计划周全再实施，这样容易因兴趣的减退、外因的阻挠错过最好的时间窗口。现在我开始习惯于兴趣驱动，抛开科学的、完善的计划，着重做和坚持。</p>

<p>于是，坚持下来了半年多的健身计划。虽然每周只练两三次，运动量也就每次做做歇歇的半个小时，而且姿势未必标准（什么是标准？），还时常变换网上流传的各种招式，但小六块的腹肌还是能证明点成效了。</p>

<p>于是，因为和妹子都喜欢《夜空中最亮的星》这首歌，在没有乐理背景的条件下，花了一个月照着乐谱学会简单的弹唱。虽然到现在为止还会在扫弦时因按不住弦发出杂音。</p>

<p>Done is better than perfect.</p>

<h2>最后</h2>

<p>很庆幸深夜的现在，我还在码字……可以睡觉啦。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/'>http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近几天]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/"/>
    <updated>2014-05-23T23:25:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/23/recent-days</id>
    <content type="html"><![CDATA[<p>再不写几篇技术博客，本站就彻底沦为个人心情垃圾桶了……在此之前，还是写写这些日子的生活吧 LOL.</p>

<h2>病痛</h2>

<p>这个伤心<del>（让人开心）</del>的故事是这样开始的。4 月底，忍耐了快两年的<code>蛀牙</code>，终于慢慢的被蛀空了，吃东西、喝凉水都疼，迫不得已去看医生。</p>

<p>看牙医的前一天晚上，发现全身起包，瘙痒难当。梦里醒来，模模糊糊的以为是饥渴的蚊子咬的，起床给全身抹了一遍六神，强忍着继续睡了。第二天，包不仅没消，还有疯长的趋势。在牙医的提点下，我又去挂了一个皮肤科，医生很淡然的告诉我这叫<code>过敏</code>。于是，在治疗蛀牙的同时，我又收获了几包抗过敏的药。</p>

<p>医生同时也告诉我，我的蛀牙已经烂到了神经，必须剔除全部神经，大概需要四五个疗程，隔周治疗一次。于是他开始打麻药钻神经了。我对麻药的药效很不敏感，总之我是能感受到那股钻心的疼痛的，咬咬牙忍了。</p>

<!--more-->


<p>过了两周，蛀牙的处理进行到后期了，拍牙片准备做牙套。拍片的时候又传来噩耗：<code>智齿横长阻生</code>，医生的建议是：为了避免它影响旁侧待补的蛀牙，拔掉它。于是，我又开起了拔智齿的线程。这颗智齿聪明的把自己埋在肉里，手术过程是：切开肉，敲碎半颗牙，拔出，缝上……手术过程在充分的麻醉下进行，并不疼。只是医生拿着锤子、凿子各路兵器敲敲打打的时候，脑子里感觉还是一阵阵轰鸣眩晕。疼的还属麻药消去的时间，只能吃流食，不能吃太热，不能吐口水……</p>

<p>还没有结束呢。前天下午觉得头痛不舒服，<code>感冒</code>了。我读书少，是个粗人，纯粹的觉得感冒这种小病，运动下就痊愈了吧，于是晚上一个人拿着篮球去投篮玩。久违的自己一个人练练球，可开心了。捡球的时候，<code>崴了脚</code>……去校医院包扎，正好开了感冒药。</p>

<p>下图就是积攒的各种各样的药片啦。</p>

<p><img src="http://biaobiaoqi.u.qiniudn.com/2014-05-22%2021.49.04.jpg?imageView/2/w/800/h/800" alt="药" /></p>

<h2>心疾</h2>

<p>身体的病，能治的去医院就好，不能治的暂时没碰到。倒是心理的焦躁很难察觉，当它肆意的蔓延开来时，已经留下了一个接一个烂坑等着你爬。这不才是现代人疏于应付的疾病么？最近的我就是一个很好的例子。</p>

<p><del>简单的讲，有时候觉得除了实验室的活儿，其他的事情我都还蛮感兴趣的。</del></p>

<p>客观的原因不提也罢，谁没几个不顺心，让不顺心搞得焦头烂额就是自己的责任了。主观原因则可以归结到自己的人生观、世界观、价值观，太大了也不方便展开。还是想想怎么解决吧。</p>

<p>对于有些人，<code>早起</code>情况能反应精神状态。我原以为我也是这样，于是经常企图用第二天早起来提升士气。后来才发现，我的精神状态指标其实不是早起，而是<code>晚睡</code>。</p>

<p>比如做<a href="http://chahaoyou.com/">查好友</a> iOS 第一版的时候，每天夜里可以编码到凌晨 4、5 点。比如当我决定补充下算法基础时，写 <a href="http://pat.zju.edu.cn/">PAT</a> 和 <a href="https://oj.leetcode.com/problems/">leetcode</a> 也可以通宵。还有一些通宵，是在查自己感兴趣的资料，写有意思的文字和代码。</p>

<p>我对睡眠的驾驭应该远低于平均水平，年少轻狂的一度以此为荣。直到觉得身体有些力不从心。身体是革命的本钱，当身体告诉我不可以，那就绝无可能把晚睡本身作为健康精神状态的指标。其实，这些晚睡无非是那些感兴趣到让我无法自拔的事情在怂恿。</p>

<p>白天在公共场合，各方面因素推着人走，只有晚上独处时，才寻得那点自由。换句话讲，如果一定要说哪些事实能标志自己的精神状态，那就是晚上睡前在做什么了。说白了，也就是自己是不是在做着自己想做的事情。</p>

<p>不过，还是那句话，谁没几个不顺心。让不顺心流淌到全身的血液，那就是幼稚了。</p>

<h2>禁欲</h2>

<p>首先，不要想歪。</p>

<p>大二的某一天，突然想削减上人人的时间，将他们拿来做点更有意思的事情。几经注销、重新登入，成功的让自己养成了在悠闲地不知道做啥时也没了上人人的欲望。</p>

<p>这次，主角变成了<del>新浪</del>微薄。当我意识到一旦思维主动或被动的空闲下来，我就会不假思索的通过<code>cmd+tab(选中 chrome) -&gt; cmd + t (打开新标签) -&gt; 输入 w(自动补全为 weibo.com) -&gt; enter</code>打开微薄页面时，我觉得是时候跟她说再见了。</p>

<p>禁言的头几天，作为思维停顿时的习惯性反射，打开微博的组合动作仍然时有发生。渐渐的就没了兴趣。除了黄海波被抓的时候看看最新的情况，隔三差五处理下艾特自己的内容，微薄淡出了自己的视野。</p>

<p>微薄禁言，似乎是个好的转变。不过触发自己转变的，想必也是比较糟糕的状态了。比如连连宵夜，比如晚上早早的跑回寝室玩耍，比如饭后闲逛网页根本停不下来……而且，也没见自己的士气有多好的提升。</p>

<p>说到底，禁欲不是为了禁谁，而是为了更好的做其他事情。没有后者，前者也只是短效的麻痹而已。</p>

<h2>做和坚持</h2>

<p>最近一段时间，终于完成了一个思维习惯的转变：以前总是事先安排、计划周全再实施，这样容易因兴趣的减退、外因的阻挠错过最好的时间窗口。现在我开始习惯于兴趣驱动，抛开科学的、完善的计划，着重做和坚持。</p>

<p>于是，坚持下来了半年多的健身计划。虽然每周只练两三次，运动量也就每次做做歇歇的半个小时，而且姿势未必标准（什么是标准？），还时常变换网上流传的各种招式，但小六块的腹肌还是能证明点成效了。</p>

<p>于是，因为和妹子都喜欢《夜空中最亮的星》这首歌，在没有乐理背景的条件下，花了一个月照着乐谱学会简单的弹唱。虽然到现在为止还会在扫弦时因按不住弦发出杂音。</p>

<p>Done is better than perfect.</p>

<h2>最后</h2>

<p>很庆幸深夜的现在，我还在码字……可以睡觉啦。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/'>http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最近几天]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/"/>
    <updated>2014-05-23T23:25:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/23/recent-days</id>
    <content type="html"><![CDATA[<p>再不写几篇技术博客，本站就彻底沦为个人心情垃圾桶了……在此之前，还是写写这些日子的生活吧 LOL.</p>

<h2>病痛</h2>

<p>这个伤心<del>（让人开心）</del>的故事是这样开始的。4 月底，忍耐了快两年的<code>蛀牙</code>，终于慢慢的被蛀空了，吃东西、喝凉水都疼，迫不得已去看医生。</p>

<p>看牙医的前一天晚上，发现全身起包，瘙痒难当。梦里醒来，模模糊糊的以为是饥渴的蚊子咬的，起床给全身抹了一遍六神，强忍着继续睡了。第二天，包不仅没消，还有疯长的趋势。在牙医的提点下，我又去挂了一个皮肤科，医生很淡然的告诉我这叫<code>过敏</code>。于是，在治疗蛀牙的同时，我又收获了几包抗过敏的药。</p>

<p>医生同时也告诉我，我的蛀牙已经烂到了神经，必须剔除全部神经，大概需要四五个疗程，隔周治疗一次。于是他开始打麻药钻神经了。我对麻药的药效很不敏感，总之我是能感受到那股钻心的疼痛的，咬咬牙忍了。</p>

<!--more-->


<p>过了两周，蛀牙的处理进行到后期了，拍牙片准备做牙套。拍片的时候又传来噩耗：<code>智齿横长阻生</code>，医生的建议是：为了避免它影响旁侧待补的蛀牙，拔掉它。于是，我又开起了拔智齿的线程。这颗智齿聪明的把自己埋在肉里，手术过程是：切开肉，敲碎半颗牙，拔出，缝上……手术过程在充分的麻醉下进行，并不疼。只是医生拿着锤子、凿子各路兵器敲敲打打的时候，脑子里感觉还是一阵阵轰鸣眩晕。疼的还属麻药消去的时间，只能吃流食，不能吃太热，不能吐口水……</p>

<p>还没有结束呢。前天下午觉得头痛不舒服，<code>感冒</code>了。我读书少，是个粗人，纯粹的觉得感冒这种小病，运动下就痊愈了吧，于是晚上一个人拿着篮球去投篮玩。久违的自己一个人练练球，可开心了。捡球的时候，<code>崴了脚</code>……去校医院包扎，正好开了感冒药。</p>

<p>下图就是积攒的各种各样的药片啦。</p>

<p><img src="http://biaobiaoqi.u.qiniudn.com/2014-05-22%2021.49.04.jpg?imageView/2/w/800/h/800" alt="药" /></p>

<h2>心疾</h2>

<p>身体的病，能治的去医院就好，不能治的暂时没碰到。倒是心理的焦躁很难察觉，当它肆意的蔓延开来时，已经留下了一个接一个烂坑等着你爬。这不才是现代人疏于应付的疾病么？最近的我就是一个很好的例子。</p>

<p><del>简单的讲，有时候觉得除了实验室的活儿，其他的事情我都还蛮感兴趣的。</del></p>

<p>客观的原因不提也罢，谁没几个不顺心，让不顺心搞得焦头烂额就是自己的责任了。主观原因则可以归结到自己的人生观、世界观、价值观，太大了也不方便展开。还是想想怎么解决吧。</p>

<p>对于有些人，<code>早起</code>情况能反应精神状态。我原以为我也是这样，于是经常企图用第二天早起来提升士气。后来才发现，我的精神状态指标其实不是早起，而是<code>晚睡</code>。</p>

<p>比如做<a href="http://chahaoyou.com/">查好友</a> iOS 第一版的时候，每天夜里可以编码到凌晨 4、5 点。比如当我决定补充下算法基础时，写 <a href="http://pat.zju.edu.cn/">PAT</a> 和 <a href="https://oj.leetcode.com/problems/">leetcode</a> 也可以通宵。还有一些通宵，是在查自己感兴趣的资料，写有意思的文字和代码。</p>

<p>我对睡眠的驾驭应该远低于平均水平，年少轻狂的一度以此为荣。直到觉得身体有些力不从心。身体是革命的本钱，当身体告诉我不可以，那就绝无可能把晚睡本身作为健康精神状态的指标。其实，这些晚睡无非是那些感兴趣到让我无法自拔的事情在怂恿。</p>

<p>白天在公共场合，各方面因素推着人走，只有晚上独处时，才寻得那点自由。换句话讲，如果一定要说哪些事实能标志自己的精神状态，那就是晚上睡前在做什么了。说白了，也就是自己是不是在做着自己想做的事情。</p>

<p>不过，还是那句话，谁没几个不顺心。让不顺心流淌到全身的血液，那就是幼稚了。</p>

<h2>禁欲</h2>

<p>首先，不要想歪。</p>

<p>大二的某一天，突然想削减上人人的时间，将他们拿来做点更有意思的事情。几经注销、重新登入，成功的让自己养成了在悠闲地不知道做啥时也没了上人人的欲望。</p>

<p>这次，主角变成了<del>新浪</del>微薄。当我意识到一旦思维主动或被动的空闲下来，我就会不假思索的通过<code>cmd+tab(选中 chrome) -&gt; cmd + t (打开新标签) -&gt; 输入 w(自动补全为 weibo.com) -&gt; enter</code>打开微薄页面时，我觉得是时候跟她说再见了。</p>

<p>禁言的头几天，作为思维停顿时的习惯性反射，打开微博的组合动作仍然时有发生。渐渐的就没了兴趣。除了黄海波被抓的时候看看最新的情况，隔三差五处理下艾特自己的内容，微薄淡出了自己的视野。</p>

<p>微薄禁言，似乎是个好的转变。不过触发自己转变的，想必也是比较糟糕的状态了。比如连连宵夜，比如晚上早早的跑回寝室玩耍，比如饭后闲逛网页根本停不下来……而且，也没见自己的士气有多好的提升。</p>

<p>说到底，禁欲不是为了禁谁，而是为了更好的做其他事情。没有后者，前者也只是短效的麻痹而已。</p>

<h2>做和坚持</h2>

<p>最近一段时间，终于完成了一个思维习惯的转变：以前总是事先安排、计划周全再实施，这样容易因兴趣的减退、外因的阻挠错过最好的时间窗口。现在我开始习惯于兴趣驱动，抛开科学的、完善的计划，着重做和坚持。</p>

<p>于是，坚持下来了半年多的健身计划。虽然每周只练两三次，运动量也就每次做做歇歇的半个小时，而且姿势未必标准（什么是标准？），还时常变换网上流传的各种招式，但小六块的腹肌还是能证明点成效了。</p>

<p>于是，因为和妹子都喜欢《夜空中最亮的星》这首歌，在没有乐理背景的条件下，花了一个月照着乐谱学会简单的弹唱。虽然到现在为止还会在扫弦时因按不住弦发出杂音。</p>

<p>Done is better than perfect.</p>

<h2>最后</h2>

<p>很庆幸深夜的现在，我还在码字……可以睡觉啦。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/'>http://biaobiaoqi.github.io/blog/2014/05/23/recent-days/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[智能手环体验：UP24]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/"/>
    <updated>2014-05-08T09:44:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>穿戴式设备承载了物联网、大数据、健康、智能等各路当下或曾经的热门词汇，其风言风语已经飘荡了两年了。当前市面上比较流行的有国外的 jawbone up 手环、NIKE 的 fuelband 和 fitbit force 手环等，国内也不乏类似产品，比如 bong、咕咚等。</p>

<p>3 月被网络各种消息吹得心痒痒，在同学的怂恿下，终于壮着胆从干瘪的口袋里挤出点钱入了一只 <a href="https://jawbone.com/up">jawbone up24</a>。用了两个月，于昨天二手出掉，原因下面会分析。首先介绍下我对外观和功能的认识。</p>

<!--more-->


<h2>外观</h2>

<p>我的是黑色款 M 号，宽松的搭在手腕上，自觉得颇具运动、休闲感，倒是被很多同学喷黑乎乎的一圈不知为何物。想想今年本命年，应该买条红色的才对，这也构成了我两个月后卖掉它的原因之一。</p>

<h2>功能体验</h2>

<p>手环本身只有一个控制按键，通过连续按下的次数来执行响应的功能。而数据展示则完全在手机端（没有网页版）。官方介绍的功能挺多的，我实际使用的也就那么几个。先说说自己觉得鸡肋的功能：</p>

<ul>
<li>食物摄入量：手动输入吃了哪些食物、喝了多少水，可以通过扫描二维码的方式输入。但我实在对这种繁琐的事情提不起兴趣。自己平时的饮食习惯都处于半失控状态，没心思再来打开应用输入。</li>
<li>特殊提醒：相当于一个事件闹钟。使用场景也比较窄，大多数情况下，手机闹钟就够了。</li>
<li>社交功能：让多个朋友一起加入一个团队比拼数据等，但是 up 手环比较小众，国内就更少了，要让社交产生效果，真的很难。毕竟硬件平台的普及相比软件成本、门槛都更高。</li>
<li>秒表：在跑步等运动时，可以用它来记录事件，但是还得打开手机查看，没有显示屏的劣势显现出来了。自己不怎么跑步，没怎么用过。</li>
<li>活动警告：设定每完成多少步就进行提醒，还可以在每天设定的时间推送运动摘要。用下来觉得挺烦的，各种提醒消息……</li>
</ul>


<p>下面是自己觉得不错的功能：</p>

<ul>
<li>记步：可以记录每天是否有行走到目标步数，以此获得成就感。</li>
<li>睡眠记录：睡眠模式中会通过肢体的活动程度来统计深浅睡眠时间等参数。不过需要手动切换睡眠模式，我碰到好几次睡前忘记切换到睡眠模式，于是丢失了当天的睡眠数据。</li>
<li>静默闹钟：在学校寝室，这种震动叫醒的方式不会对别人的睡眠造成太大影响，从这个角度来说很方便。</li>
<li>空闲提醒：设定时间长度，如果超过这个时间长度的静止，就会震动提醒。这个对于我这种长期坐在电脑前的工种意义重大。</li>
<li>小憩：可以设定小憩时间，或者让手环智能判断需要小憩的时间（需要用户给定一个范围），到点后会震动叫醒。中午在办公场所午睡，用手环震动叫醒还是很方便的。</li>
</ul>


<h2>总结</h2>

<p>购买之前，我查看了不少测评分析。自己对 UP24 的心理定位是：有助于健康保持的小闹钟。</p>

<p>实际上，它也几乎达到了这个要求，只是我自己不争气，维护健康生活作息的意识在新鲜感退去以后也渐渐消散了。加上自己对黑色的外形也越来越不感冒，从最初每天时常查看数据，到后来一个星期也没看一眼手机应用，最终还是将它卖掉了。</p>

<p>市场上唱衰智能手环的声音不少，最近的时间里，听闻 fitbit 已经停产 Force 了，原因是大约有 1%的用户反映佩带手环后皮肤过敏（原本还想试试 Force 的，只能作罢），而 Nike 则宣布不再专注于硬件研发，转而跟苹果合作，注重软件层面。经过两代产品的迭代，UP24 相比 UP 和 UP2 要成熟不少，至少没像 UP2 那样高频的出故障。</p>

<p>Jawbone 还在撑着它的小众市场，但它跟其他竞争对手面临的最大的问题一样，如何聚拢用户感兴趣的功能，如何留住用户。</p>

<p>传闻将于年底发布的 iWatch 或许值得关注。作为穿戴式设备，它背后有足够强大的苹果用户网支撑，相比 Google Glass，它更贴合当下用户的生活场景，而且苹果的产品线从来是互为增益极具粘性。已经等不及了呢 =)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/'>http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[智能手环体验：UP24]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/"/>
    <updated>2014-05-08T09:44:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>穿戴式设备承载了物联网、大数据、健康、智能等各路当下或曾经的热门词汇，其风言风语已经飘荡了两年了。当前市面上比较流行的有国外的 jawbone up 手环、NIKE 的 fuelband 和 fitbit force 手环等，国内也不乏类似产品，比如 bong、咕咚等。</p>

<p>3 月被网络各种消息吹得心痒痒，在同学的怂恿下，终于壮着胆从干瘪的口袋里挤出点钱入了一只 <a href="https://jawbone.com/up">jawbone up24</a>。用了两个月，于昨天二手出掉，原因下面会分析。首先介绍下我对外观和功能的认识。</p>

<!--more-->


<h2>外观</h2>

<p>我的是黑色款 M 号，宽松的搭在手腕上，自觉得颇具运动、休闲感，倒是被很多同学喷黑乎乎的一圈不知为何物。想想今年本命年，应该买条红色的才对，这也构成了我两个月后卖掉它的原因之一。</p>

<h2>功能体验</h2>

<p>手环本身只有一个控制按键，通过连续按下的次数来执行响应的功能。而数据展示则完全在手机端（没有网页版）。官方介绍的功能挺多的，我实际使用的也就那么几个。先说说自己觉得鸡肋的功能：</p>

<ul>
<li>食物摄入量：手动输入吃了哪些食物、喝了多少水，可以通过扫描二维码的方式输入。但我实在对这种繁琐的事情提不起兴趣。自己平时的饮食习惯都处于半失控状态，没心思再来打开应用输入。</li>
<li>特殊提醒：相当于一个事件闹钟。使用场景也比较窄，大多数情况下，手机闹钟就够了。</li>
<li>社交功能：让多个朋友一起加入一个团队比拼数据等，但是 up 手环比较小众，国内就更少了，要让社交产生效果，真的很难。毕竟硬件平台的普及相比软件成本、门槛都更高。</li>
<li>秒表：在跑步等运动时，可以用它来记录事件，但是还得打开手机查看，没有显示屏的劣势显现出来了。自己不怎么跑步，没怎么用过。</li>
<li>活动警告：设定每完成多少步就进行提醒，还可以在每天设定的时间推送运动摘要。用下来觉得挺烦的，各种提醒消息……</li>
</ul>


<p>下面是自己觉得不错的功能：</p>

<ul>
<li>记步：可以记录每天是否有行走到目标步数，以此获得成就感。</li>
<li>睡眠记录：睡眠模式中会通过肢体的活动程度来统计深浅睡眠时间等参数。不过需要手动切换睡眠模式，我碰到好几次睡前忘记切换到睡眠模式，于是丢失了当天的睡眠数据。</li>
<li>静默闹钟：在学校寝室，这种震动叫醒的方式不会对别人的睡眠造成太大影响，从这个角度来说很方便。</li>
<li>空闲提醒：设定时间长度，如果超过这个时间长度的静止，就会震动提醒。这个对于我这种长期坐在电脑前的工种意义重大。</li>
<li>小憩：可以设定小憩时间，或者让手环智能判断需要小憩的时间（需要用户给定一个范围），到点后会震动叫醒。中午在办公场所午睡，用手环震动叫醒还是很方便的。</li>
</ul>


<h2>总结</h2>

<p>购买之前，我查看了不少测评分析。自己对 UP24 的心理定位是：有助于健康保持的小闹钟。</p>

<p>实际上，它也几乎达到了这个要求，只是我自己不争气，维护健康生活作息的意识在新鲜感退去以后也渐渐消散了。加上自己对黑色的外形也越来越不感冒，从最初每天时常查看数据，到后来一个星期也没看一眼手机应用，最终还是将它卖掉了。</p>

<p>市场上唱衰智能手环的声音不少，最近的时间里，听闻 fitbit 已经停产 Force 了，原因是大约有 1%的用户反映佩带手环后皮肤过敏（原本还想试试 Force 的，只能作罢），而 Nike 则宣布不再专注于硬件研发，转而跟苹果合作，注重软件层面。经过两代产品的迭代，UP24 相比 UP 和 UP2 要成熟不少，至少没像 UP2 那样高频的出故障。</p>

<p>Jawbone 还在撑着它的小众市场，但它跟其他竞争对手面临的最大的问题一样，如何聚拢用户感兴趣的功能，如何留住用户。</p>

<p>传闻将于年底发布的 iWatch 或许值得关注。作为穿戴式设备，它背后有足够强大的苹果用户网支撑，相比 Google Glass，它更贴合当下用户的生活场景，而且苹果的产品线从来是互为增益极具粘性。已经等不及了呢 =)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/'>http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[智能手环体验：UP24]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/"/>
    <updated>2014-05-08T09:44:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p>穿戴式设备承载了物联网、大数据、健康、智能等各路当下或曾经的热门词汇，其风言风语已经飘荡了两年了。当前市面上比较流行的有国外的 jawbone up 手环、NIKE 的 fuelband 和 fitbit force 手环等，国内也不乏类似产品，比如 bong、咕咚等。</p>

<p>3 月被网络各种消息吹得心痒痒，在同学的怂恿下，终于壮着胆从干瘪的口袋里挤出点钱入了一只 <a href="https://jawbone.com/up">jawbone up24</a>。用了两个月，于昨天二手出掉，原因下面会分析。首先介绍下我对外观和功能的认识。</p>

<!--more-->


<h2>外观</h2>

<p>我的是黑色款 M 号，宽松的搭在手腕上，自觉得颇具运动、休闲感，倒是被很多同学喷黑乎乎的一圈不知为何物。想想今年本命年，应该买条红色的才对，这也构成了我两个月后卖掉它的原因之一。</p>

<h2>功能体验</h2>

<p>手环本身只有一个控制按键，通过连续按下的次数来执行响应的功能。而数据展示则完全在手机端（没有网页版）。官方介绍的功能挺多的，我实际使用的也就那么几个。先说说自己觉得鸡肋的功能：</p>

<ul>
<li>食物摄入量：手动输入吃了哪些食物、喝了多少水，可以通过扫描二维码的方式输入。但我实在对这种繁琐的事情提不起兴趣。自己平时的饮食习惯都处于半失控状态，没心思再来打开应用输入。</li>
<li>特殊提醒：相当于一个事件闹钟。使用场景也比较窄，大多数情况下，手机闹钟就够了。</li>
<li>社交功能：让多个朋友一起加入一个团队比拼数据等，但是 up 手环比较小众，国内就更少了，要让社交产生效果，真的很难。毕竟硬件平台的普及相比软件成本、门槛都更高。</li>
<li>秒表：在跑步等运动时，可以用它来记录事件，但是还得打开手机查看，没有显示屏的劣势显现出来了。自己不怎么跑步，没怎么用过。</li>
<li>活动警告：设定每完成多少步就进行提醒，还可以在每天设定的时间推送运动摘要。用下来觉得挺烦的，各种提醒消息……</li>
</ul>


<p>下面是自己觉得不错的功能：</p>

<ul>
<li>记步：可以记录每天是否有行走到目标步数，以此获得成就感。</li>
<li>睡眠记录：睡眠模式中会通过肢体的活动程度来统计深浅睡眠时间等参数。不过需要手动切换睡眠模式，我碰到好几次睡前忘记切换到睡眠模式，于是丢失了当天的睡眠数据。</li>
<li>静默闹钟：在学校寝室，这种震动叫醒的方式不会对别人的睡眠造成太大影响，从这个角度来说很方便。</li>
<li>空闲提醒：设定时间长度，如果超过这个时间长度的静止，就会震动提醒。这个对于我这种长期坐在电脑前的工种意义重大。</li>
<li>小憩：可以设定小憩时间，或者让手环智能判断需要小憩的时间（需要用户给定一个范围），到点后会震动叫醒。中午在办公场所午睡，用手环震动叫醒还是很方便的。</li>
</ul>


<h2>总结</h2>

<p>购买之前，我查看了不少测评分析。自己对 UP24 的心理定位是：有助于健康保持的小闹钟。</p>

<p>实际上，它也几乎达到了这个要求，只是我自己不争气，维护健康生活作息的意识在新鲜感退去以后也渐渐消散了。加上自己对黑色的外形也越来越不感冒，从最初每天时常查看数据，到后来一个星期也没看一眼手机应用，最终还是将它卖掉了。</p>

<p>市场上唱衰智能手环的声音不少，最近的时间里，听闻 fitbit 已经停产 Force 了，原因是大约有 1%的用户反映佩带手环后皮肤过敏（原本还想试试 Force 的，只能作罢），而 Nike 则宣布不再专注于硬件研发，转而跟苹果合作，注重软件层面。经过两代产品的迭代，UP24 相比 UP 和 UP2 要成熟不少，至少没像 UP2 那样高频的出故障。</p>

<p>Jawbone 还在撑着它的小众市场，但它跟其他竞争对手面临的最大的问题一样，如何聚拢用户感兴趣的功能，如何留住用户。</p>

<p>传闻将于年底发布的 iWatch 或许值得关注。作为穿戴式设备，它背后有足够强大的苹果用户网支撑，相比 Google Glass，它更贴合当下用户的生活场景，而且苹果的产品线从来是互为增益极具粘性。已经等不及了呢 =)</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/'>http://biaobiaoqi.github.io/blog/2014/05/08/jawbone-up24/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦 LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约 80 人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//拿到所有作业本后，每周我都需要完成如下过程：
</span><span class='line'>loop in 80+个作业本
</span><span class='line'>  拿起笔，翻开每本作业本；
</span><span class='line'>  在作业本上标记成绩；
</span><span class='line'>  放下笔，关上作业本；
</span><span class='line'>  在成绩记录表格上上 CTRL+F 查找到对应的学生；
</span><span class='line'>  输入成绩;
</span><span class='line'>end loop</span></code></pre></td></tr></table></div></figure>


<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //邮件查收实验报告
</span><span class='line'>  loop in 80+个学生的实验报告邮件；
</span><span class='line'>      保存附件；
</span><span class='line'>      回复已经收到；
</span><span class='line'>  end loop
</span><span class='line'>  
</span><span class='line'>  //收集齐所有报告后，开始批改报告
</span><span class='line'>  loop in 80+个学生的实验报告
</span><span class='line'>      双击打开报告；
</span><span class='line'>      浏览评分；
</span><span class='line'>      在成绩记录表格上 CTRL+F 查找到对应的学生；
</span><span class='line'>      输入成绩；
</span><span class='line'>      关闭报告；
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //改作业
</span><span class='line'>  拿起笔
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本；
</span><span class='line'>      在作业本上标记成绩；
</span><span class='line'>      关闭作业本；
</span><span class='line'>  end loop
</span><span class='line'>  放下笔
</span><span class='line'>  
</span><span class='line'>  //录入成绩
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本，查看成绩
</span><span class='line'>      在成绩记录表格上上 CTRL+F 查找到对应的学生；
</span><span class='line'>      输入成绩;
</span><span class='line'>      关闭作业本；
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在 A+、A、A- 这几个分数上，其他分数如 B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的 B+、B、B-等分入到 Else 作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F 查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据 [1, n]的索引就可以快速检索到了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //预处理
</span><span class='line'>  给作业本建索引
</span><span class='line'>
</span><span class='line'>  //改作业
</span><span class='line'>  拿起笔
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本；
</span><span class='line'>      在作业本上标记成绩；
</span><span class='line'>      关闭作业本；
</span><span class='line'>      将作业按照评分放入 A+、A、A-和 Else 这四个堆中
</span><span class='line'>  end loop
</span><span class='line'>  放下笔
</span><span class='line'>  
</span><span class='line'>  //录入成绩
</span><span class='line'>  loop in A+、 A、 A-、 Else 这四个作业堆
</span><span class='line'>      loop in 作业堆
</span><span class='line'>          if 作业堆 == Else 
</span><span class='line'>              翻开作业本；
</span><span class='line'>              查看成绩；
</span><span class='line'>              关上作业本；
</span><span class='line'>          end if
</span><span class='line'>          根据索引查找到学生；
</span><span class='line'>          输入成绩;
</span><span class='line'>      end loop
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建 FTP；使用工具（比如 Acrobat）将所有报告连接成单个 pdf 文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>//预处理
</span><span class='line'>FTP 收集报告
</span><span class='line'>使用 Acrobat 将所有 pdf 报告连接成一个汇总报告
</span><span class='line'>
</span><span class='line'>//批改报告和录入成绩
</span><span class='line'>双击打开汇总报告；
</span><span class='line'>loop in 80+个学生的实验报告
</span><span class='line'>  浏览评分；
</span><span class='line'>  在成绩记录表格上 CTRL+F 查找到对应的学生；
</span><span class='line'>  输入成绩；
</span><span class='line'>end loop
</span><span class='line'>关闭汇总报告；
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用 pdf 和姓名加学号的命名提交作业，也一定会有学生会使用 doc 格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/'>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦 LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约 80 人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//拿到所有作业本后，每周我都需要完成如下过程：
</span><span class='line'>loop in 80+个作业本
</span><span class='line'>  拿起笔，翻开每本作业本；
</span><span class='line'>  在作业本上标记成绩；
</span><span class='line'>  放下笔，关上作业本；
</span><span class='line'>  在成绩记录表格上上 CTRL+F 查找到对应的学生；
</span><span class='line'>  输入成绩;
</span><span class='line'>end loop</span></code></pre></td></tr></table></div></figure>


<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //邮件查收实验报告
</span><span class='line'>  loop in 80+个学生的实验报告邮件；
</span><span class='line'>      保存附件；
</span><span class='line'>      回复已经收到；
</span><span class='line'>  end loop
</span><span class='line'>  
</span><span class='line'>  //收集齐所有报告后，开始批改报告
</span><span class='line'>  loop in 80+个学生的实验报告
</span><span class='line'>      双击打开报告；
</span><span class='line'>      浏览评分；
</span><span class='line'>      在成绩记录表格上 CTRL+F 查找到对应的学生；
</span><span class='line'>      输入成绩；
</span><span class='line'>      关闭报告；
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //改作业
</span><span class='line'>  拿起笔
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本；
</span><span class='line'>      在作业本上标记成绩；
</span><span class='line'>      关闭作业本；
</span><span class='line'>  end loop
</span><span class='line'>  放下笔
</span><span class='line'>  
</span><span class='line'>  //录入成绩
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本，查看成绩
</span><span class='line'>      在成绩记录表格上上 CTRL+F 查找到对应的学生；
</span><span class='line'>      输入成绩;
</span><span class='line'>      关闭作业本；
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在 A+、A、A- 这几个分数上，其他分数如 B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的 B+、B、B-等分入到 Else 作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F 查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据 [1, n]的索引就可以快速检索到了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //预处理
</span><span class='line'>  给作业本建索引
</span><span class='line'>
</span><span class='line'>  //改作业
</span><span class='line'>  拿起笔
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本；
</span><span class='line'>      在作业本上标记成绩；
</span><span class='line'>      关闭作业本；
</span><span class='line'>      将作业按照评分放入 A+、A、A-和 Else 这四个堆中
</span><span class='line'>  end loop
</span><span class='line'>  放下笔
</span><span class='line'>  
</span><span class='line'>  //录入成绩
</span><span class='line'>  loop in A+、 A、 A-、 Else 这四个作业堆
</span><span class='line'>      loop in 作业堆
</span><span class='line'>          if 作业堆 == Else 
</span><span class='line'>              翻开作业本；
</span><span class='line'>              查看成绩；
</span><span class='line'>              关上作业本；
</span><span class='line'>          end if
</span><span class='line'>          根据索引查找到学生；
</span><span class='line'>          输入成绩;
</span><span class='line'>      end loop
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建 FTP；使用工具（比如 Acrobat）将所有报告连接成单个 pdf 文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>//预处理
</span><span class='line'>FTP 收集报告
</span><span class='line'>使用 Acrobat 将所有 pdf 报告连接成一个汇总报告
</span><span class='line'>
</span><span class='line'>//批改报告和录入成绩
</span><span class='line'>双击打开汇总报告；
</span><span class='line'>loop in 80+个学生的实验报告
</span><span class='line'>  浏览评分；
</span><span class='line'>  在成绩记录表格上 CTRL+F 查找到对应的学生；
</span><span class='line'>  输入成绩；
</span><span class='line'>end loop
</span><span class='line'>关闭汇总报告；
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用 pdf 和姓名加学号的命名提交作业，也一定会有学生会使用 doc 格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/'>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[课程助教实战]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/"/>
    <updated>2014-05-06T20:06:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice</id>
    <content type="html"><![CDATA[<p>原谅我的标题党啦 LOL，借用 《xx 实战》（xx in practice）这个经典的标题，只为了记录自己第一次助教的体会。</p>

<p>如果把第一次助教的经历看做是一个项目，那这个项目也是在我不断的调优中走上正轨的。</p>

<h2>需求</h2>

<p>导师人很好，给我留的活儿不多，但实践起来还是比预想要复杂一些。助教期间，我主要负责的任务有：</p>

<ul>
<li><p>平时作业的批改和成绩录入</p>

<p>  每周老师会将所有学生（大约 80 人）的作业本交给我，由我评分、录入成绩后返回给老师。</p></li>
<li><p>课程实验和大程的指导、评分和成绩录入</p>

<p>  一共有五个课堂实验，要求每周完成一个，以实验报告的形式提交；期末要求完成一个大程序，评分有现场验收和大程报告两部分。</p></li>
<li><p>协助老师批改期末试卷和成绩录入</p></li>
</ul>


<p>最后的批改试卷是在老师们的指导下完成，有良好的规范和流程。而前面两步中关于作业评分、登分的部分则有较大的自由实现空间。下面介绍的就是个人对这部分内容经验总结。</p>

<!--more-->


<h2>初步实现策略</h2>

<p>最朴素的实现方法，会耗费很多的时间，但至少能完成任务：</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//拿到所有作业本后，每周我都需要完成如下过程：
</span><span class='line'>loop in 80+个作业本
</span><span class='line'>  拿起笔，翻开每本作业本；
</span><span class='line'>  在作业本上标记成绩；
</span><span class='line'>  放下笔，关上作业本；
</span><span class='line'>  在成绩记录表格上上 CTRL+F 查找到对应的学生；
</span><span class='line'>  输入成绩;
</span><span class='line'>end loop</span></code></pre></td></tr></table></div></figure>


<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //邮件查收实验报告
</span><span class='line'>  loop in 80+个学生的实验报告邮件；
</span><span class='line'>      保存附件；
</span><span class='line'>      回复已经收到；
</span><span class='line'>  end loop
</span><span class='line'>  
</span><span class='line'>  //收集齐所有报告后，开始批改报告
</span><span class='line'>  loop in 80+个学生的实验报告
</span><span class='line'>      双击打开报告；
</span><span class='line'>      浏览评分；
</span><span class='line'>      在成绩记录表格上 CTRL+F 查找到对应的学生；
</span><span class='line'>      输入成绩；
</span><span class='line'>      关闭报告；
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<h2>性能调优</h2>

<p>最朴素的方法在使用中带来了巨大的性能瓶颈。</p>

<ul>
<li>平时作业的批改和成绩录入</li>
</ul>


<p>实践发现，批改平时作业和登分的过程中，会花掉非常多的实践在拿起笔、放下笔上，就像程序的上下文切换，比较耗时。将批改作业和录入成绩分解成两个集中循环过程，就可以避免这一切换的开销。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //改作业
</span><span class='line'>  拿起笔
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本；
</span><span class='line'>      在作业本上标记成绩；
</span><span class='line'>      关闭作业本；
</span><span class='line'>  end loop
</span><span class='line'>  放下笔
</span><span class='line'>  
</span><span class='line'>  //录入成绩
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本，查看成绩
</span><span class='line'>      在成绩记录表格上上 CTRL+F 查找到对应的学生；
</span><span class='line'>      输入成绩;
</span><span class='line'>      关闭作业本；
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<p>以上的实现中，作业登分时还是会有大量的翻开、关闭作业本的操作。实际上，批改作业的等级是非常有限的，一般集中在 A+、A、A- 这几个分数上，其他分数如 B+、B、B-只是极少数。很容易想到桶排序的方式：批改作业时，将不同评分的作业放在专属的作业堆中，录入成绩时，只需要按照不同的作业堆录入，而不用翻开作业本。另外，由于书桌空间有限无法设定较多的作业堆，可以将出现较少的 B+、B、B-等分入到 Else 作业堆，批改时再特殊处理。</p>

<p>在给同学登分时，每次都需要根据学号或者姓名 CTRL+F 查找，比较繁琐。优化的方法是建索引。在成绩录入表中给所有同学设定一个简单的编号，然后在同学的作业本的封皮上标记出来，以后每次登分，直接根据 [1, n]的索引就可以快速检索到了。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>  //预处理
</span><span class='line'>  给作业本建索引
</span><span class='line'>
</span><span class='line'>  //改作业
</span><span class='line'>  拿起笔
</span><span class='line'>  loop in 80+个作业本
</span><span class='line'>      翻开作业本；
</span><span class='line'>      在作业本上标记成绩；
</span><span class='line'>      关闭作业本；
</span><span class='line'>      将作业按照评分放入 A+、A、A-和 Else 这四个堆中
</span><span class='line'>  end loop
</span><span class='line'>  放下笔
</span><span class='line'>  
</span><span class='line'>  //录入成绩
</span><span class='line'>  loop in A+、 A、 A-、 Else 这四个作业堆
</span><span class='line'>      loop in 作业堆
</span><span class='line'>          if 作业堆 == Else 
</span><span class='line'>              翻开作业本；
</span><span class='line'>              查看成绩；
</span><span class='line'>              关上作业本；
</span><span class='line'>          end if
</span><span class='line'>          根据索引查找到学生；
</span><span class='line'>          输入成绩;
</span><span class='line'>      end loop
</span><span class='line'>  end loop
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>课程实验和大程的指导、评分和成绩录入</li>
</ul>


<p>在收集实验报告的时候，每次回复邮件也是很头痛的一件事情，容易漏掉回复或者漏掉保存附件。而给报告评分时，也得不断的点开某个文档，然后录入成绩，再关闭这个文档，容易漏评。虽然以在给所有同学评分完毕后再依次清查漏掉的情况，但这个方法确实不够优美。</p>

<p>改进方法是：放弃使用邮件提交报告的方法，搭建 FTP；使用工具（比如 Acrobat）将所有报告连接成单个 pdf 文件。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>
</span><span class='line'>//预处理
</span><span class='line'>FTP 收集报告
</span><span class='line'>使用 Acrobat 将所有 pdf 报告连接成一个汇总报告
</span><span class='line'>
</span><span class='line'>//批改报告和录入成绩
</span><span class='line'>双击打开汇总报告；
</span><span class='line'>loop in 80+个学生的实验报告
</span><span class='line'>  浏览评分；
</span><span class='line'>  在成绩记录表格上 CTRL+F 查找到对应的学生；
</span><span class='line'>  输入成绩；
</span><span class='line'>end loop
</span><span class='line'>关闭汇总报告；
</span></code></pre></td></tr></table></div></figure>


<h2>总结</h2>

<p>以上记录的是可以用工程的优化方法解决的小问题。实际助教的过程中，还有不少是沟通的问题。比如即使告诉过学生们一定使用 pdf 和姓名加学号的命名提交作业，也一定会有学生会使用 doc 格式……还有一些策略权衡的问题，面对几十个学生不比一对一的交流，合适的方法会双方更高效。</p>

<p>做助教容易，做好不易，且行且珍惜。</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/'>http://biaobiaoqi.github.io/blog/2014/05/06/ta-in-practice/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记排查octopress生成时的编码错误]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/"/>
    <updated>2014-03-06T21:48:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress</id>
    <content type="html"><![CDATA[<p>前些日子经若亮童鞋提醒，我在<a href="http://biaobiaoqi.github.io/resources/">其他推荐</a>的页面中增加了对 Dropbox 和 Linode 等工具的推荐，一来分享这些好用的产品，二来期望刚接触这些工具的好心的朋友可以不吝啬时间用我的推荐码注册，让我获得一些分享的回报。</p>

<p>改过页面内容后，照常的使用<code>rake preview</code>命令生成预览页面，打开浏览器，得到的却是一行孤零零的</p>

<blockquote><p>Sorry, I can not find /</p></blockquote>

<p><code>rake generate</code>后的结果更悲惨：</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>biaobiaoqi.github.com git:(source) ✗ rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>unchanged sass/screen.scss
</span><span class='line'>Configuration from /Users/shenyapeng/Development/biaobiaoqi.github.com/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>/Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/raw.rb:11:in `gsub': invalid byte sequence in UTF-8 (ArgumentError)
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/raw.rb:11:in `unwrap'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/octopress_filters.rb:18:in `post_filter'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/octopress_filters.rb:33:in `post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:124:in `block in post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:123:in `each'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:123:in `post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:151:in `transform'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/convertible.rb:88:in `do_layout'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:167:in `do_layout'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/page.rb:100:in `render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:204:in `block in render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:203:in `each'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:203:in `render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:41:in `process'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/bin/jekyll:264:in `&lt;top (required)&gt;'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/jekyll:23:in `load'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/jekyll:23:in `&lt;main&gt;'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/ruby_executable_hooks:15:in `eval'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/ruby_executable_hooks:15:in `&lt;main&gt;’</span></code></pre></td></tr></table></div></figure>


<p>似乎是编码的问题：<code>invalid byte sequence in UTF-8</code>，但是我只是修改了普普通通的几行文字而已，怎么会有编码问题呢。</p>

<p>恰逢自己刚因为 SSD 损坏重装了系统，编程环境也是刚刚配好，而且使用 rvm 安装 ruby1.9.3 的时候，提示文字中也有一些 warning。我开始怀疑是不是 ruby1.9.3 没编译好的原因。</p>

<p>设立对照实验，我在另外一台 Ubuntu 机器上 clone 下一个博客的 repo，<code>rake generate</code>，结果竟然一切顺利。一切似乎都在说明就是开发环境的问题。</p>

<p>我删除了之前的 ruby1.9.3，甚至是 rvm，重装后结果依旧。</p>

<p>不能在一棵树上吊死，我不科学的将目标重新定位到 markdown 页面中的编码错误上（没想到后来事实证明奏效了……）。</p>

<p>在 git 中新开启测试分支，在上面做回滚，测试修改页面内容前源码能否 generate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&gt;git branch checkError
</span><span class='line'>#&gt;git checkout checkError
</span><span class='line'>
</span><span class='line'>#&gt;git log #找到修改前的提交码
</span><span class='line'>#&gt;git reset --hard xxx #xxx 为相应的提交码
</span></code></pre></td></tr></table></div></figure>


<p>然后<code>rake generate</code>竟然能成功= =#!，看来真的是修改的页面掺入了错误的编码。</p>

<p>接下来是回到原来的分支上，通过 diff 命令定位错误代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&gt;git checkout source 
</span><span class='line'>#&gt;git branch -d checkError  #删除测试分支
</span><span class='line'>
</span><span class='line'>#&gt;git diff  xxx #xxx 为相应的提交码
</span></code></pre></td></tr></table></div></figure>


<p>比较结果如下图，果然是有一个奇怪的字符。
<img src="http://biaobiaoqi.u.qiniudn.com/8BB0BA73-9736-435D-9111-5E3BF8516299.png?imageView/2/w/800/h/800" alt="img" /></p>

<p>查了下，这是<a href="http://zh.wikipedia.org/wiki/%E5%B7%A6%E8%87%B3%E5%8F%B3%E7%AC%A6%E8%99%9F">左至右符号</a>。莫非是从 chrome 浏览器复制地址时，不小心复制了它？</p>

<p>进一步尝试发现，这个字符如果不与)相邻，是不会造成编码问题的。与)相邻时，一旦他们被 markdown 解析后，就出现了这个 bug。</p>

<p>有意思的是，另一台 Ubuntu 服务器上这个有编码隐患的 repo 时能够正常<code>rake generate</code>的。如下图，左边是 mac 上用 vim 打开包含隐患字符的文件截图，右边是 Ubuntu 上的截图。
<img src="http://biaobiaoqi.u.qiniudn.com/371c00e86e5de776d262fedbce334f7a.jpeg?imageView/2/w/800/h/800" alt="img" /></p>

<p>谁能告诉我理解这一现象的思路呢 >&lt;&#8230;</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/'>http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记排查octopress生成时的编码错误]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/"/>
    <updated>2014-03-06T21:48:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress</id>
    <content type="html"><![CDATA[<p>前些日子经若亮童鞋提醒，我在<a href="http://biaobiaoqi.github.io/resources/">其他推荐</a>的页面中增加了对 Dropbox 和 Linode 等工具的推荐，一来分享这些好用的产品，二来期望刚接触这些工具的好心的朋友可以不吝啬时间用我的推荐码注册，让我获得一些分享的回报。</p>

<p>改过页面内容后，照常的使用<code>rake preview</code>命令生成预览页面，打开浏览器，得到的却是一行孤零零的</p>

<blockquote><p>Sorry, I can not find /</p></blockquote>

<p><code>rake generate</code>后的结果更悲惨：</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>biaobiaoqi.github.com git:(source) ✗ rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>unchanged sass/screen.scss
</span><span class='line'>Configuration from /Users/shenyapeng/Development/biaobiaoqi.github.com/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>/Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/raw.rb:11:in `gsub': invalid byte sequence in UTF-8 (ArgumentError)
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/raw.rb:11:in `unwrap'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/octopress_filters.rb:18:in `post_filter'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/octopress_filters.rb:33:in `post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:124:in `block in post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:123:in `each'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:123:in `post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:151:in `transform'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/convertible.rb:88:in `do_layout'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:167:in `do_layout'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/page.rb:100:in `render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:204:in `block in render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:203:in `each'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:203:in `render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:41:in `process'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/bin/jekyll:264:in `&lt;top (required)&gt;'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/jekyll:23:in `load'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/jekyll:23:in `&lt;main&gt;'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/ruby_executable_hooks:15:in `eval'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/ruby_executable_hooks:15:in `&lt;main&gt;’</span></code></pre></td></tr></table></div></figure>


<p>似乎是编码的问题：<code>invalid byte sequence in UTF-8</code>，但是我只是修改了普普通通的几行文字而已，怎么会有编码问题呢。</p>

<p>恰逢自己刚因为 SSD 损坏重装了系统，编程环境也是刚刚配好，而且使用 rvm 安装 ruby1.9.3 的时候，提示文字中也有一些 warning。我开始怀疑是不是 ruby1.9.3 没编译好的原因。</p>

<p>设立对照实验，我在另外一台 Ubuntu 机器上 clone 下一个博客的 repo，<code>rake generate</code>，结果竟然一切顺利。一切似乎都在说明就是开发环境的问题。</p>

<p>我删除了之前的 ruby1.9.3，甚至是 rvm，重装后结果依旧。</p>

<p>不能在一棵树上吊死，我不科学的将目标重新定位到 markdown 页面中的编码错误上（没想到后来事实证明奏效了……）。</p>

<p>在 git 中新开启测试分支，在上面做回滚，测试修改页面内容前源码能否 generate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&gt;git branch checkError
</span><span class='line'>#&gt;git checkout checkError
</span><span class='line'>
</span><span class='line'>#&gt;git log #找到修改前的提交码
</span><span class='line'>#&gt;git reset --hard xxx #xxx 为相应的提交码
</span></code></pre></td></tr></table></div></figure>


<p>然后<code>rake generate</code>竟然能成功= =#!，看来真的是修改的页面掺入了错误的编码。</p>

<p>接下来是回到原来的分支上，通过 diff 命令定位错误代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&gt;git checkout source 
</span><span class='line'>#&gt;git branch -d checkError  #删除测试分支
</span><span class='line'>
</span><span class='line'>#&gt;git diff  xxx #xxx 为相应的提交码
</span></code></pre></td></tr></table></div></figure>


<p>比较结果如下图，果然是有一个奇怪的字符。
<img src="http://biaobiaoqi.u.qiniudn.com/8BB0BA73-9736-435D-9111-5E3BF8516299.png?imageView/2/w/800/h/800" alt="img" /></p>

<p>查了下，这是<a href="http://zh.wikipedia.org/wiki/%E5%B7%A6%E8%87%B3%E5%8F%B3%E7%AC%A6%E8%99%9F">左至右符号</a>。莫非是从 chrome 浏览器复制地址时，不小心复制了它？</p>

<p>进一步尝试发现，这个字符如果不与)相邻，是不会造成编码问题的。与)相邻时，一旦他们被 markdown 解析后，就出现了这个 bug。</p>

<p>有意思的是，另一台 Ubuntu 服务器上这个有编码隐患的 repo 时能够正常<code>rake generate</code>的。如下图，左边是 mac 上用 vim 打开包含隐患字符的文件截图，右边是 Ubuntu 上的截图。
<img src="http://biaobiaoqi.u.qiniudn.com/371c00e86e5de776d262fedbce334f7a.jpeg?imageView/2/w/800/h/800" alt="img" /></p>

<p>谁能告诉我理解这一现象的思路呢 >&lt;&#8230;</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/'>http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[记排查octopress生成时的编码错误]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/"/>
    <updated>2014-03-06T21:48:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress</id>
    <content type="html"><![CDATA[<p>前些日子经若亮童鞋提醒，我在<a href="http://biaobiaoqi.github.io/resources/">其他推荐</a>的页面中增加了对 Dropbox 和 Linode 等工具的推荐，一来分享这些好用的产品，二来期望刚接触这些工具的好心的朋友可以不吝啬时间用我的推荐码注册，让我获得一些分享的回报。</p>

<p>改过页面内容后，照常的使用<code>rake preview</code>命令生成预览页面，打开浏览器，得到的却是一行孤零零的</p>

<blockquote><p>Sorry, I can not find /</p></blockquote>

<p><code>rake generate</code>后的结果更悲惨：</p>

<!--more-->




<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>biaobiaoqi.github.com git:(source) ✗ rake generate
</span><span class='line'>## Generating Site with Jekyll
</span><span class='line'>unchanged sass/screen.scss
</span><span class='line'>Configuration from /Users/shenyapeng/Development/biaobiaoqi.github.com/_config.yml
</span><span class='line'>Building site: source -&gt; public
</span><span class='line'>/Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/raw.rb:11:in `gsub': invalid byte sequence in UTF-8 (ArgumentError)
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/raw.rb:11:in `unwrap'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/octopress_filters.rb:18:in `post_filter'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/octopress_filters.rb:33:in `post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:124:in `block in post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:123:in `each'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:123:in `post_render'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:151:in `transform'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/convertible.rb:88:in `do_layout'
</span><span class='line'>     from /Users/shenyapeng/Development/biaobiaoqi.github.com/plugins/post_filters.rb:167:in `do_layout'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/page.rb:100:in `render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:204:in `block in render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:203:in `each'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:203:in `render'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/lib/jekyll/site.rb:41:in `process'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/gems/jekyll-0.12.1/bin/jekyll:264:in `&lt;top (required)&gt;'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/jekyll:23:in `load'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/jekyll:23:in `&lt;main&gt;'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/ruby_executable_hooks:15:in `eval'
</span><span class='line'>     from /Users/shenyapeng/.rvm/gems/ruby-1.9.3-p545/bin/ruby_executable_hooks:15:in `&lt;main&gt;’</span></code></pre></td></tr></table></div></figure>


<p>似乎是编码的问题：<code>invalid byte sequence in UTF-8</code>，但是我只是修改了普普通通的几行文字而已，怎么会有编码问题呢。</p>

<p>恰逢自己刚因为 SSD 损坏重装了系统，编程环境也是刚刚配好，而且使用 rvm 安装 ruby1.9.3 的时候，提示文字中也有一些 warning。我开始怀疑是不是 ruby1.9.3 没编译好的原因。</p>

<p>设立对照实验，我在另外一台 Ubuntu 机器上 clone 下一个博客的 repo，<code>rake generate</code>，结果竟然一切顺利。一切似乎都在说明就是开发环境的问题。</p>

<p>我删除了之前的 ruby1.9.3，甚至是 rvm，重装后结果依旧。</p>

<p>不能在一棵树上吊死，我不科学的将目标重新定位到 markdown 页面中的编码错误上（没想到后来事实证明奏效了……）。</p>

<p>在 git 中新开启测试分支，在上面做回滚，测试修改页面内容前源码能否 generate</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&gt;git branch checkError
</span><span class='line'>#&gt;git checkout checkError
</span><span class='line'>
</span><span class='line'>#&gt;git log #找到修改前的提交码
</span><span class='line'>#&gt;git reset --hard xxx #xxx 为相应的提交码
</span></code></pre></td></tr></table></div></figure>


<p>然后<code>rake generate</code>竟然能成功= =#!，看来真的是修改的页面掺入了错误的编码。</p>

<p>接下来是回到原来的分支上，通过 diff 命令定位错误代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>#&gt;git checkout source 
</span><span class='line'>#&gt;git branch -d checkError  #删除测试分支
</span><span class='line'>
</span><span class='line'>#&gt;git diff  xxx #xxx 为相应的提交码
</span></code></pre></td></tr></table></div></figure>


<p>比较结果如下图，果然是有一个奇怪的字符。
<img src="http://biaobiaoqi.u.qiniudn.com/8BB0BA73-9736-435D-9111-5E3BF8516299.png?imageView/2/w/800/h/800" alt="img" /></p>

<p>查了下，这是<a href="http://zh.wikipedia.org/wiki/%E5%B7%A6%E8%87%B3%E5%8F%B3%E7%AC%A6%E8%99%9F">左至右符号</a>。莫非是从 chrome 浏览器复制地址时，不小心复制了它？</p>

<p>进一步尝试发现，这个字符如果不与)相邻，是不会造成编码问题的。与)相邻时，一旦他们被 markdown 解析后，就出现了这个 bug。</p>

<p>有意思的是，另一台 Ubuntu 服务器上这个有编码隐患的 repo 时能够正常<code>rake generate</code>的。如下图，左边是 mac 上用 vim 打开包含隐患字符的文件截图，右边是 Ubuntu 上的截图。
<img src="http://biaobiaoqi.u.qiniudn.com/371c00e86e5de776d262fedbce334f7a.jpeg?imageView/2/w/800/h/800" alt="img" /></p>

<p>谁能告诉我理解这一现象的思路呢 >&lt;&#8230;</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/'>http://biaobiaoqi.github.io/blog/2014/03/06/troubleshoot-encoding-bugs-in-octopress/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在 wiki 上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证 2 个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java 实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int temp = 0;
</span><span class='line'>for (int i = a.length - 1; i &gt; 0; --i) {
</span><span class='line'>  for (int j = 0; j &lt; i; ++j) {
</span><span class='line'>    if (a[j + 1] &lt; a[j]) {
</span><span class='line'>      temp = a[j];
</span><span class='line'>      a[j] = a[j + 1];
</span><span class='line'>      a[j + 1] = temp;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现 O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(int index=1;index&lt;data.length;index++){  
</span><span class='line'>  Comparable key = data[index];  
</span><span class='line'>  int position = index;  
</span><span class='line'>    //shift larger values to the right  
</span><span class='line'>    while(position&gt;0&&data[position-1].compareTo(key)&gt;0){  
</span><span class='line'>      data[position] = data[position-1];  
</span><span class='line'>        position--;
</span><span class='line'>      }  
</span><span class='line'>    data[position]=key;  
</span><span class='line'>}     </span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (int index = 0; index &lt; array.length - 1; index++) {
</span><span class='line'>  min = index;
</span><span class='line'>  for (int time = index + 1; time &lt; array.length; time++) {
</span><span class='line'>      if (array[time].compareTo(array[min]) &lt; 0) {
</span><span class='line'>          min = time;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  temp = array[index];
</span><span class='line'>  array[index] = array[min];
</span><span class='line'>  array[min] = temp;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在 [0]和 [3]之间，[0]的 3 被交换到 [2]的 3 之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为 pivot，代码实现中取第一个元素为 pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void sort (int[] input){
</span><span class='line'>      sort (input, 0, input.length-1);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private void sort(int[] input, int lowIndex, int highIndex) { 
</span><span class='line'>  if (highIndex&lt;=lowIndex){
</span><span class='line'>      return;
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  int partIndex=partition (input, lowIndex, highIndex);
</span><span class='line'> 
</span><span class='line'>    sort (input, lowIndex, partIndex-1);
</span><span class='line'>    sort (input, partIndex+1, highIndex);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>private int partition(int[] input, int lowIndex, int highIndex) {
</span><span class='line'>  int i=lowIndex;
</span><span class='line'>  int pivotIndex=lowIndex;
</span><span class='line'>    int j=highIndex+1;
</span><span class='line'>
</span><span class='line'>    while (true){
</span><span class='line'>      while (less(input[++i], input[pivotIndex])){
</span><span class='line'>          if (i==highIndex) break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        while (less (input[pivotIndex], input[--j])){
</span><span class='line'>          if (j==lowIndex) break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (i&gt;=j) break;
</span><span class='line'>
</span><span class='line'>        exchange(input, i, j);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>    exchange(input, pivotIndex, j);
</span><span class='line'>
</span><span class='line'>    return j;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取</sup> pivot 不够科学，在有序或者逆序的情况下会产生 n<sup>2</sup> 的时间开销。</li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的 3 会被交换到 10 和 11 的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对 pivot 的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays 中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有 n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的 K 个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void sort(Integer[] list) {
</span><span class='line'>  if (list.length == 0) {
</span><span class='line'>      System.out.println("");
</span><span class='line'>  } else {
</span><span class='line'>      Integer[] tmpList = new Integer[list.length];
</span><span class='line'>      mergeSort(list, 0, list.length - 1, tmpList);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void mergeSort(Integer[] list, int leftPos, int rightPos,
</span><span class='line'>      Integer[] tmpList) {
</span><span class='line'>  if (leftPos &gt;= rightPos)
</span><span class='line'>      return;
</span><span class='line'>
</span><span class='line'>  int center = (leftPos + rightPos) / 2;
</span><span class='line'>  mergeSort(list, leftPos, center, tmpList);
</span><span class='line'>  mergeSort(list, center + 1, rightPos, tmpList);
</span><span class='line'>  merge(list, leftPos, center, rightPos, tmpList);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,
</span><span class='line'>      Integer[] tmpList) {
</span><span class='line'>  int leftIndex  = leftPos;
</span><span class='line'>  int rightIndex = leftEnd + 1;
</span><span class='line'>  int index = leftIndex;
</span><span class='line'>  
</span><span class='line'>  while (leftIndex &lt;= leftEnd && rightIndex &lt;= rightEnd) {
</span><span class='line'>      if (list[leftIndex] &lt;= list[rightIndex]) {
</span><span class='line'>          tmpList[index++] = list[leftIndex++];
</span><span class='line'>      } else {
</span><span class='line'>          tmpList[index++] = list[rightIndex++];
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  while (leftIndex &lt;= leftEnd) {
</span><span class='line'>      tmpList[index++] = list[leftIndex++];
</span><span class='line'>  }
</span><span class='line'>  while (rightIndex &lt;= rightEnd) {
</span><span class='line'>      tmpList[index++] = list[rightIndex++];
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  for (int i = leftPos; i &lt;= rightEnd; i ++) {
</span><span class='line'>      list[i] = tmpList[i];
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java 的 java.util.Arrays 中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public int leftChild(int n) {
</span><span class='line'>  return 2*n + 1;
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>public void percolateDown(int[] list, int n, int length) {
</span><span class='line'>  int tmp;
</span><span class='line'>  int child;
</span><span class='line'>  
</span><span class='line'>  for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
</span><span class='line'>      child = leftChild(n);
</span><span class='line'>      
</span><span class='line'>      if (child + 1 &lt; length && list[child] &lt; list[child + 1]) {
</span><span class='line'>          child ++;
</span><span class='line'>      }
</span><span class='line'>      
</span><span class='line'>      if (tmp &lt; list[child]) {
</span><span class='line'>          list[n] = list[child];
</span><span class='line'>      }else {
</span><span class='line'>          break;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  list[n] = tmp;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void sort(int[] list) {
</span><span class='line'>  for (int i = list.length/2; i &gt;= 0; i --) {
</span><span class='line'>      percolateDown(list, i, list.length);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  for (int i = list.length - 1; i &gt; 0; i --) {
</span><span class='line'>      int tmp = list[i];
</span><span class='line'>      list[i] = list[0];
</span><span class='line'>      list[0] = tmp;
</span><span class='line'>      
</span><span class='line'>      percolateDown(list, 0, i);
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个 27 后，原来在后面的 27 被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求 topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并 1 中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N 个数组的排序，有 N!种可能结果，我们需要在 N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为 1/2 和 1/2，也就一次比较中 a<b 的概率和 a>b 的概率一样，如果能保证一这一点，就能保证最优下界，也就是 log2(N!)，这个值近似于 NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序 wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode 总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/'>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在 wiki 上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证 2 个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java 实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int temp = 0;
</span><span class='line'>for (int i = a.length - 1; i &gt; 0; --i) {
</span><span class='line'>  for (int j = 0; j &lt; i; ++j) {
</span><span class='line'>    if (a[j + 1] &lt; a[j]) {
</span><span class='line'>      temp = a[j];
</span><span class='line'>      a[j] = a[j + 1];
</span><span class='line'>      a[j + 1] = temp;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现 O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(int index=1;index&lt;data.length;index++){  
</span><span class='line'>  Comparable key = data[index];  
</span><span class='line'>  int position = index;  
</span><span class='line'>    //shift larger values to the right  
</span><span class='line'>    while(position&gt;0&&data[position-1].compareTo(key)&gt;0){  
</span><span class='line'>      data[position] = data[position-1];  
</span><span class='line'>        position--;
</span><span class='line'>      }  
</span><span class='line'>    data[position]=key;  
</span><span class='line'>}     </span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (int index = 0; index &lt; array.length - 1; index++) {
</span><span class='line'>  min = index;
</span><span class='line'>  for (int time = index + 1; time &lt; array.length; time++) {
</span><span class='line'>      if (array[time].compareTo(array[min]) &lt; 0) {
</span><span class='line'>          min = time;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  temp = array[index];
</span><span class='line'>  array[index] = array[min];
</span><span class='line'>  array[min] = temp;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在 [0]和 [3]之间，[0]的 3 被交换到 [2]的 3 之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为 pivot，代码实现中取第一个元素为 pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void sort (int[] input){
</span><span class='line'>      sort (input, 0, input.length-1);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private void sort(int[] input, int lowIndex, int highIndex) { 
</span><span class='line'>  if (highIndex&lt;=lowIndex){
</span><span class='line'>      return;
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  int partIndex=partition (input, lowIndex, highIndex);
</span><span class='line'> 
</span><span class='line'>    sort (input, lowIndex, partIndex-1);
</span><span class='line'>    sort (input, partIndex+1, highIndex);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>private int partition(int[] input, int lowIndex, int highIndex) {
</span><span class='line'>  int i=lowIndex;
</span><span class='line'>  int pivotIndex=lowIndex;
</span><span class='line'>    int j=highIndex+1;
</span><span class='line'>
</span><span class='line'>    while (true){
</span><span class='line'>      while (less(input[++i], input[pivotIndex])){
</span><span class='line'>          if (i==highIndex) break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        while (less (input[pivotIndex], input[--j])){
</span><span class='line'>          if (j==lowIndex) break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (i&gt;=j) break;
</span><span class='line'>
</span><span class='line'>        exchange(input, i, j);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>    exchange(input, pivotIndex, j);
</span><span class='line'>
</span><span class='line'>    return j;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取</sup> pivot 不够科学，在有序或者逆序的情况下会产生 n<sup>2</sup> 的时间开销。</li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的 3 会被交换到 10 和 11 的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对 pivot 的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays 中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有 n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的 K 个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void sort(Integer[] list) {
</span><span class='line'>  if (list.length == 0) {
</span><span class='line'>      System.out.println("");
</span><span class='line'>  } else {
</span><span class='line'>      Integer[] tmpList = new Integer[list.length];
</span><span class='line'>      mergeSort(list, 0, list.length - 1, tmpList);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void mergeSort(Integer[] list, int leftPos, int rightPos,
</span><span class='line'>      Integer[] tmpList) {
</span><span class='line'>  if (leftPos &gt;= rightPos)
</span><span class='line'>      return;
</span><span class='line'>
</span><span class='line'>  int center = (leftPos + rightPos) / 2;
</span><span class='line'>  mergeSort(list, leftPos, center, tmpList);
</span><span class='line'>  mergeSort(list, center + 1, rightPos, tmpList);
</span><span class='line'>  merge(list, leftPos, center, rightPos, tmpList);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,
</span><span class='line'>      Integer[] tmpList) {
</span><span class='line'>  int leftIndex  = leftPos;
</span><span class='line'>  int rightIndex = leftEnd + 1;
</span><span class='line'>  int index = leftIndex;
</span><span class='line'>  
</span><span class='line'>  while (leftIndex &lt;= leftEnd && rightIndex &lt;= rightEnd) {
</span><span class='line'>      if (list[leftIndex] &lt;= list[rightIndex]) {
</span><span class='line'>          tmpList[index++] = list[leftIndex++];
</span><span class='line'>      } else {
</span><span class='line'>          tmpList[index++] = list[rightIndex++];
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  while (leftIndex &lt;= leftEnd) {
</span><span class='line'>      tmpList[index++] = list[leftIndex++];
</span><span class='line'>  }
</span><span class='line'>  while (rightIndex &lt;= rightEnd) {
</span><span class='line'>      tmpList[index++] = list[rightIndex++];
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  for (int i = leftPos; i &lt;= rightEnd; i ++) {
</span><span class='line'>      list[i] = tmpList[i];
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java 的 java.util.Arrays 中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public int leftChild(int n) {
</span><span class='line'>  return 2*n + 1;
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>public void percolateDown(int[] list, int n, int length) {
</span><span class='line'>  int tmp;
</span><span class='line'>  int child;
</span><span class='line'>  
</span><span class='line'>  for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
</span><span class='line'>      child = leftChild(n);
</span><span class='line'>      
</span><span class='line'>      if (child + 1 &lt; length && list[child] &lt; list[child + 1]) {
</span><span class='line'>          child ++;
</span><span class='line'>      }
</span><span class='line'>      
</span><span class='line'>      if (tmp &lt; list[child]) {
</span><span class='line'>          list[n] = list[child];
</span><span class='line'>      }else {
</span><span class='line'>          break;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  list[n] = tmp;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void sort(int[] list) {
</span><span class='line'>  for (int i = list.length/2; i &gt;= 0; i --) {
</span><span class='line'>      percolateDown(list, i, list.length);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  for (int i = list.length - 1; i &gt; 0; i --) {
</span><span class='line'>      int tmp = list[i];
</span><span class='line'>      list[i] = list[0];
</span><span class='line'>      list[0] = tmp;
</span><span class='line'>      
</span><span class='line'>      percolateDown(list, 0, i);
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个 27 后，原来在后面的 27 被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求 topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并 1 中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N 个数组的排序，有 N!种可能结果，我们需要在 N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为 1/2 和 1/2，也就一次比较中 a<b 的概率和 a>b 的概率一样，如果能保证一这一点，就能保证最优下界，也就是 log2(N!)，这个值近似于 NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序 wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode 总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/'>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基本排序总结]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/"/>
    <updated>2014-02-24T23:58:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro</id>
    <content type="html"><![CDATA[<p>最近准备面试，正好把刚接触数据结构时学习的排序整理了一下。算法的实现在 wiki 上都有详细的介绍，这里主要做归纳和总结。</p>

<p>注意对排序算法的稳定性的理解：保证 2 个相等的数在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。换句话说，相等的数值在排序时不断交换位置是不稳定的。</p>

<!--more-->


<h2>冒泡排序</h2>

<p>使用冒泡排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/3/37/Bubble_sort_animation.gif" alt="冒泡排序" /></p>

<p>Java 实现：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>int temp = 0;
</span><span class='line'>for (int i = a.length - 1; i &gt; 0; --i) {
</span><span class='line'>  for (int j = 0; j &lt; i; ++j) {
</span><span class='line'>    if (a[j + 1] &lt; a[j]) {
</span><span class='line'>      temp = a[j];
</span><span class='line'>      a[j] = a[j + 1];
</span><span class='line'>      a[j + 1] = temp;
</span><span class='line'>    }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：在遍历时，如果有设定标记，对于已排序的数组，可以实现 O(n)</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>插入排序</h2>

<p>使用插入排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/2/25/Insertion_sort_animation.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for(int index=1;index&lt;data.length;index++){  
</span><span class='line'>  Comparable key = data[index];  
</span><span class='line'>  int position = index;  
</span><span class='line'>    //shift larger values to the right  
</span><span class='line'>    while(position&gt;0&&data[position-1].compareTo(key)&gt;0){  
</span><span class='line'>      data[position] = data[position-1];  
</span><span class='line'>        position--;
</span><span class='line'>      }  
</span><span class='line'>    data[position]=key;  
</span><span class='line'>}     </span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n<sup>2)</sup></li>
<li>最优时间复杂度：O(n)：顺序的情况。</li>
<li>平均时间复杂度：O(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<h2>选择排序</h2>

<p>使用选择排序为一列数字进行排序的过程如下图：</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>for (int index = 0; index &lt; array.length - 1; index++) {
</span><span class='line'>  min = index;
</span><span class='line'>  for (int time = index + 1; time &lt; array.length; time++) {
</span><span class='line'>      if (array[time].compareTo(array[min]) &lt; 0) {
</span><span class='line'>          min = time;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  temp = array[index];
</span><span class='line'>  array[index] = array[min];
</span><span class='line'>  array[min] = temp;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：О(n<sup>2)</sup></li>
<li>最优时间复杂度：О(n<sup>2):比插入、冒泡都还要弱。</sup></li>
<li>平均时间复杂度：О(n<sup>2)</sup></li>
<li>最差空间复杂度：总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。比如对于数组{3,2,3,1}, 第一次交换发生在 [0]和 [3]之间，[0]的 3 被交换到 [2]的 3 之后了。</li>
</ul>


<h2>快速排序</h2>

<p>使用快速排序为一列数字进行排序的过程如下图：（图中取最后一个元素为 pivot，代码实现中取第一个元素为 pivot）</p>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/6/6a/Sorting_quicksort_anim.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void sort (int[] input){
</span><span class='line'>      sort (input, 0, input.length-1);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private void sort(int[] input, int lowIndex, int highIndex) { 
</span><span class='line'>  if (highIndex&lt;=lowIndex){
</span><span class='line'>      return;
</span><span class='line'>      }
</span><span class='line'> 
</span><span class='line'>  int partIndex=partition (input, lowIndex, highIndex);
</span><span class='line'> 
</span><span class='line'>    sort (input, lowIndex, partIndex-1);
</span><span class='line'>    sort (input, partIndex+1, highIndex);
</span><span class='line'>}
</span><span class='line'> 
</span><span class='line'>private int partition(int[] input, int lowIndex, int highIndex) {
</span><span class='line'>  int i=lowIndex;
</span><span class='line'>  int pivotIndex=lowIndex;
</span><span class='line'>    int j=highIndex+1;
</span><span class='line'>
</span><span class='line'>    while (true){
</span><span class='line'>      while (less(input[++i], input[pivotIndex])){
</span><span class='line'>          if (i==highIndex) break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        while (less (input[pivotIndex], input[--j])){
</span><span class='line'>          if (j==lowIndex) break;
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        if (i&gt;=j) break;
</span><span class='line'>
</span><span class='line'>        exchange(input, i, j);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>    exchange(input, pivotIndex, j);
</span><span class='line'>
</span><span class='line'>    return j;
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：Theta(n<sup>2)：如果选取</sup> pivot 不够科学，在有序或者逆序的情况下会产生 n<sup>2</sup> 的时间开销。</li>
<li>最优时间复杂度：Theta(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：根据实现的方式不同而不，基本快排中总共 O(n) ，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。比如：{5, 10, 11, 3, 3, 3}，后面相等的 3 会被交换到 10 和 11 的位置，而且两者相对位置会变化。</li>
</ul>


<p>快速排序的分治(divide and conquer)思想非常经典。算法实现上，对 pivot 的选取也有不同的策略来做优化。比如可以选取数组的第一个元素、最后一个元素和中间元素中排中间大小的那一个。这里介绍的是快排的基础算法，也叫单基算法，还有<a href="http://www.importnew.com/8445.html">双基、三基快速排序</a>。java.util.Arrays 中对基本类型的排序就使用了双基快排（一般对象类型使用的归并排序）。</p>

<p>虽然快速排序最差时间复杂度有 n<sup>2，不过这种情况很少见，像它的名字那样，是内部排序中最快的。</sup></p>

<p>适用场景：topK：寻找最大的 K 个数</p>

<h2>归并排序</h2>

<p><img src="http://upload.wikimedia.org/wikipedia/commons/c/c5/Merge_sort_animation2.gif" alt="" /></p>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public void sort(Integer[] list) {
</span><span class='line'>  if (list.length == 0) {
</span><span class='line'>      System.out.println("");
</span><span class='line'>  } else {
</span><span class='line'>      Integer[] tmpList = new Integer[list.length];
</span><span class='line'>      mergeSort(list, 0, list.length - 1, tmpList);
</span><span class='line'>  }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void mergeSort(Integer[] list, int leftPos, int rightPos,
</span><span class='line'>      Integer[] tmpList) {
</span><span class='line'>  if (leftPos &gt;= rightPos)
</span><span class='line'>      return;
</span><span class='line'>
</span><span class='line'>  int center = (leftPos + rightPos) / 2;
</span><span class='line'>  mergeSort(list, leftPos, center, tmpList);
</span><span class='line'>  mergeSort(list, center + 1, rightPos, tmpList);
</span><span class='line'>  merge(list, leftPos, center, rightPos, tmpList);
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void merge(Integer[] list, int leftPos, int leftEnd, int rightEnd,
</span><span class='line'>      Integer[] tmpList) {
</span><span class='line'>  int leftIndex  = leftPos;
</span><span class='line'>  int rightIndex = leftEnd + 1;
</span><span class='line'>  int index = leftIndex;
</span><span class='line'>  
</span><span class='line'>  while (leftIndex &lt;= leftEnd && rightIndex &lt;= rightEnd) {
</span><span class='line'>      if (list[leftIndex] &lt;= list[rightIndex]) {
</span><span class='line'>          tmpList[index++] = list[leftIndex++];
</span><span class='line'>      } else {
</span><span class='line'>          tmpList[index++] = list[rightIndex++];
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  while (leftIndex &lt;= leftEnd) {
</span><span class='line'>      tmpList[index++] = list[leftIndex++];
</span><span class='line'>  }
</span><span class='line'>  while (rightIndex &lt;= rightEnd) {
</span><span class='line'>      tmpList[index++] = list[rightIndex++];
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>  for (int i = leftPos; i &lt;= rightEnd; i ++) {
</span><span class='line'>      list[i] = tmpList[i];
</span><span class='line'>  }
</span><span class='line'>
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：Theta(n*logn)</li>
<li>最优时间复杂度：Theta(n)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：稳定</li>
</ul>


<p>Java 的 java.util.Arrays 中对一般对象的排序使用了改良的归并算法：待排序的数组元素少于<code>INSERTIONSORT_THRESHOLD</code>时，执行插入排序。</p>

<p>归并排序比堆稍快，但需要一倍的额外存储空间。经常使用的场景：两个已排序数组合并;单向链表排序。</p>

<h2>堆排序</h2>

<p>Java 实现</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>public int leftChild(int n) {
</span><span class='line'>  return 2*n + 1;
</span><span class='line'>} 
</span><span class='line'>
</span><span class='line'>public void percolateDown(int[] list, int n, int length) {
</span><span class='line'>  int tmp;
</span><span class='line'>  int child;
</span><span class='line'>  
</span><span class='line'>  for (tmp = list[n]; leftChild(n) &lt; length; n = child) {
</span><span class='line'>      child = leftChild(n);
</span><span class='line'>      
</span><span class='line'>      if (child + 1 &lt; length && list[child] &lt; list[child + 1]) {
</span><span class='line'>          child ++;
</span><span class='line'>      }
</span><span class='line'>      
</span><span class='line'>      if (tmp &lt; list[child]) {
</span><span class='line'>          list[n] = list[child];
</span><span class='line'>      }else {
</span><span class='line'>          break;
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  list[n] = tmp;
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>public void sort(int[] list) {
</span><span class='line'>  for (int i = list.length/2; i &gt;= 0; i --) {
</span><span class='line'>      percolateDown(list, i, list.length);
</span><span class='line'>  }
</span><span class='line'>  
</span><span class='line'>  for (int i = list.length - 1; i &gt; 0; i --) {
</span><span class='line'>      int tmp = list[i];
</span><span class='line'>      list[i] = list[0];
</span><span class='line'>      list[0] = tmp;
</span><span class='line'>      
</span><span class='line'>      percolateDown(list, 0, i);
</span><span class='line'>  }
</span><span class='line'>}
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>最差时间复杂度：O(n*logn)</li>
<li>最优时间复杂度：O(n*logn)</li>
<li>平均时间复杂度：Theta(n*logn)</li>
<li>最差空间复杂度：总共 O(n)，需要辅助空间 O(1)</li>
<li>稳定性：不稳定。从堆顶摘掉放入堆尾，如果有跟它相等的值，一定会改变相对位置。比如{3, 27, 36, 27}，对大堆摘掉第一个 27 后，原来在后面的 27 被放到了堆顶。</li>
</ul>


<p>不需要递归、额外空间，适用于数据量特别大的场景，比如海量数据求 topK。除了这里的堆排序外，还需要掌握向堆中插入数据。</p>

<h2>外排序</h2>

<p>通常来说，外排序处理的数据不能一次装入内存，只能放在读写较慢的外存储器（通常是硬盘）上。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。然后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p>

<p>常用思路：</p>

<ol>
<li>使用快速排序、归并排序、堆排序等算法完成少量数据的排序，生成临时数据文件。</li>
<li>使用败者树或最小堆，用归并的思路合并 1 中生成的临时文件，并输出为最后的排序结果。</li>
</ol>


<h2>快排为什么那样快</h2>

<p>刘未鹏在<a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">《数学之美番外篇：快排为什么那样快》</a>中从问题域向答案域演进的角度解释了基于比较的排序的时间复杂度极限。</p>

<p>核心思想是：N 个数组的排序，有 N!种可能结果，我们需要在 N!中搜索出唯一正确的结果。基于比较的排序每次能输出的结果只有两种：是或否，一个只有两种输出的问题，最多能将可能性空间切分为两半，要让结果稳定可靠，最好的办法就是平均的切分为 1/2 和 1/2，也就一次比较中 a<b 的概率和 a>b 的概率一样，如果能保证一这一点，就能保证最优下界，也就是 log2(N!)，这个值近似于 NlogN。</p>

<ul>
<li><p>堆排序比快排慢：堆建立好之后，每次取堆顶，将堆尾的数据放到堆顶向下过滤，实际上，堆顶部的元素几乎肯定较大，而堆尾的数据都比较小，在向下过滤的过程中，浪费了很多次比较，让堆排序的速度变慢了。</p></li>
<li><p>基数排序比快排快：基数排序不是比较排序，将基数相同的元素放到一个桶里的操作，除了一次与技术本身的比较以外，不同的基数桶自然的形成了排序。这里基数桶用空间换取了时间。</p></li>
</ul>


<h2>参考资料</h2>

<ul>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序 wiki</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a></li>
<li><a href="http://www.importnew.com/8445.html">本周算法：快速排序—三路快排 vs 双基准</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a></li>
<li><a href="http://zh.wikipedia.org/zh-cn/%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%A4%96%E6%8E%92%E5%BA%8F">外部排序</a></li>
<li><a href="http://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a></li>
<li><a href="http://cuijing.org/study/summary-of-sort-in-leetcode.html">leetcode 总结无止境系列之排序</a></li>
<li><a href="http://mindhacks.cn/2008/06/13/why-is-quicksort-so-quick/">数学之美番外篇：快排为什么那样快</a></li>
</ul>


<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/'>http://biaobiaoqi.github.io/blog/2014/02/24/sort-intro/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linode跨节点迁移：从Tokyo到Fremont]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont/"/>
    <updated>2014-01-26T01:45:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://biaobiaoqi.github.io/blog/2014/01/22/email-3/">上一篇博客</a>交代了如何在 Linode 上搭建邮件服务器，并配置好各种协议、记录来投入实际使用。</p>

<p>由于实践过程中，曾经尝试使用明文协议与服务器交流数据，可能泄露了账号、密码信息，造成之后被攻击发送垃圾邮件(详细情况类似于如下链接：<a href="http://linuxroad.blog.51cto.com/765922/1039676">链接 1</a>,<a href="http://linuxroad.blog.51cto.com/765922/1039675">链接 2</a>)，IP 被上了黑名单，在 <a href="http://www.mail-tester.com">mail-tester.com</a> 上的测试评分为 0 分，同时还收到了 Linode 的警告。</p>

<p>为了能继续使用邮箱服务，我只好想着法子给 Linode 换一个 IP。但原则上 Linode 是不支持换 IP 的。幸运的是，它支持 VPS 的迁移，而且方便快捷。从 Tokyo 节点迁移到 Fremont 节点后 IP 一般会发生变动（对于网络延迟，权衡了下<a href="http://www.v2ex.com/t/62721">大家</a>的说法,Fremont 还不错:<a href="https://www.linode.com/speedtest/">官方测速</a>），这样就可以间接的更换 IP 了。</p>

<p>迁移过程很简单，这里做一下记录。</p>

<!--more-->


<h2>迁移准备</h2>

<h3>发出迁移请求</h3>

<p>Linode 有比较完善的 <a href="https://manager.linode.com/support">Support</a>。对于迁移这种情况，可以在 Support 页面发出如下请求：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hi,
</span><span class='line'>
</span><span class='line'>I've met with some problems with my server. And I think it's a solution to migrate my server from Tokyo to Fremont.
</span><span class='line'>
</span><span class='line'>Could you please do me a favor?
</span><span class='line'>
</span><span class='line'>Thanks a lot!</span></code></pre></td></tr></table></div></figure>


<p>1 分钟之后，我就收到了技术支持的回复：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hello,
</span><span class='line'>
</span><span class='line'>Your migration to our Fremont datacenter has been configured. Please log into the Linode Manager, shut down, and click the migrate button to move to your new server. Your disk images will be moved with you. The migration should take approximately 10-15 minutes per gigabyte of data to complete. Please note that any existing backups for this Linode will be purged and will not be recoverable after you initiate the migration.
</span><span class='line'>
</span><span class='line'>Your new IP address is: xxx.xxx.xxx.xxx
</span><span class='line'>
</span><span class='line'>We ask that you begin this migration within 24 hours and let us know when it is complete. Thanks in advance!
</span><span class='line'>
</span><span class='line'>Regards,
</span><span class='line'>Jack Stitt
</span></code></pre></td></tr></table></div></figure>


<p>此时，Linode 控制面板中已经多了一个迁移的提醒：<code>You have a migration pending!</code>。</p>

<p>不过先不要着急迁移，因为迁移过程是不可恢复的，我们需要首先将 VPS 中得重要数据备份到本地。注意如回复中所说，这种备份不同于 Linode 中的备份服务。</p>

<h3>备份数据</h3>

<p>找到一份科学的全盘备份数据方式：<a href="http://www.linode.im/1590.html">linode 用户通过 ssh+dd 命令复制整个磁盘</a>。不可否认 dd 做传输比 scp 一个个拷贝文件快得多，但由于需要将整个盘 5G 数据全部通过网络传输，而家里网速慢，传输数据只有大概 100KB/s 的速度，需要等待太长时间。</p>

<p>实际上，我所需要备份的文件无非是<code>/home</code>目录下得所有数据和部分服务的配置数据（比如 postfix、dovecot、nginx 等），总共大概也就 100MB，于是决定选择性的用 scp 传输备份数据：</p>

<p><code>scp root@vps-ip:/backup /home/backup #vps-ip 替换为服务器 IP 地址</code></p>

<p>同时由于零散的传输文件效率不高，可以考虑先将服务器端所有小文件使用 tar 命令压缩到一个包里：</p>

<p><code>tar zcvf backup.gz /home /etc/nginx/sites-enable</code></p>

<p>在本地的解压缩命令如下：</p>

<p><code>tar zxvf backup.gz</code></p>

<p>当然，实际上我们都不会希望备份数据需要被使用到啦，而迁移 vps 丢失数据的概率应该也是很小的。</p>

<h3>修改 DNS 记录</h3>

<p>由于迁移过程需要大概一个多小时，网站服务的不可访问是无法避免了。只好尽可能将迁移过程放在深夜没有用户访问需求的时候。</p>

<p>从这个角度讲，DNS 的修改也没有特别的及时性要求。在前已完成前修改好 DNS 服务器中的 A 记录、MX 记录等配置即可。</p>

<h2>迁移</h2>

<p>在正式迁移之前，需要关闭服务器。</p>

<p>然后点击 Linode 控制面板中的 migration 按钮。接下来，就是一个多小时的等待。</p>

<h2>后续</h2>

<p>完成迁移之后，开启 VPS，还需要注意修改服务中 IP 相关的配置。比如 shadowsocks 里的 json.config 中的 server ip。</p>

<p>一切顺利完成后，别忘了去 Support 界面回复 Ticket =).</p>

<p>如果你考虑租用 Linode 机器，而又不吝啬使用<a href="https://www.linode.com/?r=06fc7f86359e92800c41177a80c5678ecfcb2568">我的推荐码</a>，本博客不胜感激=).</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont/'>http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linode跨节点迁移：从Tokyo到Fremont]]></title>
    <link href="http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont/"/>
    <updated>2014-01-26T01:45:00+08:00</updated>
    <id>http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont</id>
    <content type="html"><![CDATA[<h2>背景</h2>

<p><a href="http://biaobiaoqi.github.io/blog/2014/01/22/email-3/">上一篇博客</a>交代了如何在 Linode 上搭建邮件服务器，并配置好各种协议、记录来投入实际使用。</p>

<p>由于实践过程中，曾经尝试使用明文协议与服务器交流数据，可能泄露了账号、密码信息，造成之后被攻击发送垃圾邮件(详细情况类似于如下链接：<a href="http://linuxroad.blog.51cto.com/765922/1039676">链接 1</a>,<a href="http://linuxroad.blog.51cto.com/765922/1039675">链接 2</a>)，IP 被上了黑名单，在 <a href="http://www.mail-tester.com">mail-tester.com</a> 上的测试评分为 0 分，同时还收到了 Linode 的警告。</p>

<p>为了能继续使用邮箱服务，我只好想着法子给 Linode 换一个 IP。但原则上 Linode 是不支持换 IP 的。幸运的是，它支持 VPS 的迁移，而且方便快捷。从 Tokyo 节点迁移到 Fremont 节点后 IP 一般会发生变动（对于网络延迟，权衡了下<a href="http://www.v2ex.com/t/62721">大家</a>的说法,Fremont 还不错:<a href="https://www.linode.com/speedtest/">官方测速</a>），这样就可以间接的更换 IP 了。</p>

<p>迁移过程很简单，这里做一下记录。</p>

<!--more-->


<h2>迁移准备</h2>

<h3>发出迁移请求</h3>

<p>Linode 有比较完善的 <a href="https://manager.linode.com/support">Support</a>。对于迁移这种情况，可以在 Support 页面发出如下请求：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hi,
</span><span class='line'>
</span><span class='line'>I've met with some problems with my server. And I think it's a solution to migrate my server from Tokyo to Fremont.
</span><span class='line'>
</span><span class='line'>Could you please do me a favor?
</span><span class='line'>
</span><span class='line'>Thanks a lot!</span></code></pre></td></tr></table></div></figure>


<p>1 分钟之后，我就收到了技术支持的回复：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Hello,
</span><span class='line'>
</span><span class='line'>Your migration to our Fremont datacenter has been configured. Please log into the Linode Manager, shut down, and click the migrate button to move to your new server. Your disk images will be moved with you. The migration should take approximately 10-15 minutes per gigabyte of data to complete. Please note that any existing backups for this Linode will be purged and will not be recoverable after you initiate the migration.
</span><span class='line'>
</span><span class='line'>Your new IP address is: xxx.xxx.xxx.xxx
</span><span class='line'>
</span><span class='line'>We ask that you begin this migration within 24 hours and let us know when it is complete. Thanks in advance!
</span><span class='line'>
</span><span class='line'>Regards,
</span><span class='line'>Jack Stitt
</span></code></pre></td></tr></table></div></figure>


<p>此时，Linode 控制面板中已经多了一个迁移的提醒：<code>You have a migration pending!</code>。</p>

<p>不过先不要着急迁移，因为迁移过程是不可恢复的，我们需要首先将 VPS 中得重要数据备份到本地。注意如回复中所说，这种备份不同于 Linode 中的备份服务。</p>

<h3>备份数据</h3>

<p>找到一份科学的全盘备份数据方式：<a href="http://www.linode.im/1590.html">linode 用户通过 ssh+dd 命令复制整个磁盘</a>。不可否认 dd 做传输比 scp 一个个拷贝文件快得多，但由于需要将整个盘 5G 数据全部通过网络传输，而家里网速慢，传输数据只有大概 100KB/s 的速度，需要等待太长时间。</p>

<p>实际上，我所需要备份的文件无非是<code>/home</code>目录下得所有数据和部分服务的配置数据（比如 postfix、dovecot、nginx 等），总共大概也就 100MB，于是决定选择性的用 scp 传输备份数据：</p>

<p><code>scp root@vps-ip:/backup /home/backup #vps-ip 替换为服务器 IP 地址</code></p>

<p>同时由于零散的传输文件效率不高，可以考虑先将服务器端所有小文件使用 tar 命令压缩到一个包里：</p>

<p><code>tar zcvf backup.gz /home /etc/nginx/sites-enable</code></p>

<p>在本地的解压缩命令如下：</p>

<p><code>tar zxvf backup.gz</code></p>

<p>当然，实际上我们都不会希望备份数据需要被使用到啦，而迁移 vps 丢失数据的概率应该也是很小的。</p>

<h3>修改 DNS 记录</h3>

<p>由于迁移过程需要大概一个多小时，网站服务的不可访问是无法避免了。只好尽可能将迁移过程放在深夜没有用户访问需求的时候。</p>

<p>从这个角度讲，DNS 的修改也没有特别的及时性要求。在前已完成前修改好 DNS 服务器中的 A 记录、MX 记录等配置即可。</p>

<h2>迁移</h2>

<p>在正式迁移之前，需要关闭服务器。</p>

<p>然后点击 Linode 控制面板中的 migration 按钮。接下来，就是一个多小时的等待。</p>

<h2>后续</h2>

<p>完成迁移之后，开启 VPS，还需要注意修改服务中 IP 相关的配置。比如 shadowsocks 里的 json.config 中的 server ip。</p>

<p>一切顺利完成后，别忘了去 Support 界面回复 Ticket =).</p>

<p>如果你考虑租用 Linode 机器，而又不吝啬使用<a href="https://www.linode.com/?r=06fc7f86359e92800c41177a80c5678ecfcb2568">我的推荐码</a>，本博客不胜感激=).</p>

<p class='post-footer'>&nbsp;原文地址：<a href='http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont/'>http://biaobiaoqi.github.io/blog/2014/01/26/migrate-linode-vps-from-tokyo-to-fremont/</a><br/>&nbsp;版权声明：自由转载-非商用-非衍生-保持署名| <a href='http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh'>Creative Commons BY-NC-ND 3.0</a></p>

]]></content>
  </entry>
  
</feed>
